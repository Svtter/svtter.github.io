<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Gevent on Svtter's Blog</title><link>https://svtter.cn/tags/gevent/</link><description>Recent content in Gevent on Svtter's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 28 Sep 2022 08:55:43 +0800</lastBuildDate><atom:link href="https://svtter.cn/tags/gevent/index.xml" rel="self" type="application/rss+xml"/><item><title>Good Gevent</title><link>https://svtter.cn/p/good-gevent/</link><pubDate>Wed, 28 Sep 2022 08:55:43 +0800</pubDate><guid>https://svtter.cn/p/good-gevent/</guid><description>&lt;p&gt;Gevent 是一个非常好用的异步工具，能够自动将阻塞的代码转换成非阻塞的代码。&lt;/p&gt;
&lt;p&gt;这个功能是通过&lt;code&gt;MonkeyPatch&lt;/code&gt;来实现的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MonkeyPatch&lt;/code&gt;通过 Hook 底层的代码库，来实现上层代码无变更，透明的底层实现更改。&lt;/p&gt;
&lt;p&gt;在底层，Gevent 使用的库是&lt;code&gt;libev&lt;/code&gt;或者&lt;code&gt;libuv&lt;/code&gt;。这是实现了与&lt;code&gt;nodejs&lt;/code&gt;同级别的高性能。&lt;/p&gt;
&lt;h2 id="io模型"&gt;IO模型
&lt;/h2&gt;&lt;p&gt;如果读者尚未理解非阻塞，那么建议看一下IO的四种模型。分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同步阻塞&lt;/li&gt;
&lt;li&gt;同步非阻塞&lt;/li&gt;
&lt;li&gt;IO多路复用&lt;/li&gt;
&lt;li&gt;异步IO&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在不同场景下选择不同的IO模型，可以有效的利用系统资源，更快的响应用户的请求。&lt;/p&gt;
&lt;h2 id="io-slow-problem"&gt;IO slow problem
&lt;/h2&gt;&lt;p&gt;之所以会有IO问题存在，原因有两个:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IO 设备的速度慢；&lt;/li&gt;
&lt;li&gt;用户态和内核态的转变；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;IO 设备速度慢，就要等待 IO 读取。&lt;/p&gt;
&lt;p&gt;用户态进程必须通过系统调用，向内核发出指令，才能调用系统资源。
此外，用户态进程进行读写操作的时候，必然涉及到缓冲区。
读写操作不会直接对设备进行。因此，在进行读操作的时候，
系统从设备将数据读取，拷贝到内核缓冲区。用户进程如果想要使用
读取的数据，须从内核缓冲区复制到进程缓冲区。&lt;/p&gt;
&lt;p&gt;因此，速度慢了，等待就耗时。反应到用户层面，就会出现，用户新开浏览器，但是系统仍然没有反应的情况。&lt;/p&gt;</description></item></channel></rss>