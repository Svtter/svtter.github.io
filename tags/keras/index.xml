<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Keras on Svtter's Blog</title><link>https://svtter.cn/tags/keras/</link><description>Recent content in Keras on Svtter's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 07 Jan 2019 01:00:00 +0800</lastBuildDate><atom:link href="https://svtter.cn/tags/keras/index.xml" rel="self" type="application/rss+xml"/><item><title>My Keras tricks</title><link>https://svtter.cn/p/my-keras-tricks/</link><pubDate>Mon, 07 Jan 2019 01:00:00 +0800</pubDate><guid>https://svtter.cn/p/my-keras-tricks/</guid><description>&lt;p&gt;记录了一些使用 keras 的技巧。&lt;/p&gt;
&lt;h2 id="categorical_crossentropy-vs-sparse_categorical_crossentropy"&gt;categorical_crossentropy vs sparse_categorical_crossentropy.
&lt;/h2&gt;&lt;h4 id="3-the-answerin-a-nutshell"&gt;3. The Answer, In a Nutshell
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If your targets are one-hot encoded, use categorical_crossentropy.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Examples of &lt;a href="https://jovianlin.io/keras-one-hot-encode-decode-sequence-data/" target="_blank" rel="noreferrer noopener"&gt;one-hot encodings&lt;/a&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[1,0,0]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[0,1,0]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[0,0,1]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;But if your targets are integers, use sparse_categorical_crossentropy.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Examples of integer encodings (&lt;em&gt;for the sake of completion&lt;/em&gt;):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1, 2, 3&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="clip-norm"&gt;&lt;strong&gt;clip norm&lt;/strong&gt;
&lt;/h2&gt;&lt;p style="text-align:center"&gt;
&lt;br /&gt;&lt;a rel="noreferrer noopener" href="https://wulc.me/2018/05/01/%E6%A2%AF%E5%BA%A6%E8%A3%81%E5%89%AA%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8/" target="_blank"&gt;https://wulc.me/2018/05/01/%E6%A2%AF%E5%BA%A6%E8%A3%81%E5%89%AA%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8/&lt;/a&gt;&lt;br /&gt;可以加速 RNN 训练
&lt;/p&gt;
&lt;h2 id="multiple-gpu"&gt;&lt;strong&gt;Multiple GPU&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;# &lt;a class="link" href="https://keras.io/utils/#multi" target="_blank" rel="noopener"
&gt;https://keras.io/utils/#multi&lt;/a&gt;_gpu_model#&lt;/p&gt;
&lt;p&gt;使用多GPU，注意使用 save 的时候，传参传 model (multi_gpu_model的model参数)&lt;/p&gt;
&lt;h2 id="encode-labels"&gt;&lt;strong&gt;Encode Labels&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;可以把不同的字符[‘aa’, ‘bb’, ‘cc’, ‘aa’] 编码成 [0, 1, 2, 0]&lt;/p&gt;
&lt;table class="wp-block-table"&gt;
&lt;tr&gt;
&lt;td&gt;
1&lt;br /&gt;2&lt;br /&gt;3&lt;br /&gt;4&lt;br /&gt;5&lt;br /&gt;6
&lt;/td&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;
# encode class values as integers&amp;lt;br /&amp;gt;encoder&amp;amp;nbsp;=&amp;amp;nbsp;LabelEncoder()&amp;lt;br /&amp;gt;encoder.fit(Y)&amp;lt;br /&amp;gt;encoded_Y&amp;amp;nbsp;=&amp;amp;nbsp;encoder.transform(Y)&amp;lt;br /&amp;gt;# convert integers to dummy variables (i.e. one hot encoded)&amp;lt;br /&amp;gt;dummy_y&amp;amp;nbsp;=&amp;amp;nbsp;np_utils.to_categorical(encoded_Y)
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;h2 id="训练中存在的问题"&gt;训练中存在的问题
&lt;/h2&gt;&lt;p&gt;训练性能低了别急着调参，首先看看数据预处理有没有问题，评价指标是不是写错了。再一个，batch norm 要勤快点加上。&lt;/p&gt;
&lt;p&gt;相似的文章还有：&lt;a class="link" href="https://svtter.github.io/2018/02/01/keras%e5%9d%91/" target="_blank" rel="noopener"
&gt;https://svtter.github.io/2018/02/01/keras%e5%9d%91/&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Keras坑</title><link>https://svtter.cn/p/keras%E5%9D%91/</link><pubDate>Thu, 01 Feb 2018 01:00:00 +0800</pubDate><guid>https://svtter.cn/p/keras%E5%9D%91/</guid><description>&lt;p&gt;使用Keras做分类的时候踩了一个坑，也是拿来主义的锅，估计也有不少同志遇到。&lt;/p&gt;
&lt;p&gt;在进行分类的时候，往往使用&lt;code&gt;categorical_crossentropy&lt;/code&gt;，有时候萌新（像我）会用&lt;code&gt;binary_crossentropy&lt;/code&gt;，虽然结果可能上浮30%，但是这个结果是不对的。&lt;code&gt;model.fit&lt;/code&gt;以及&lt;code&gt;model.evaluate&lt;/code&gt;给出的&lt;code&gt;acc&lt;/code&gt;的值都是有问题的，正确的计算方法应该是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# Actual accuracy calculated manually:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;y_pred&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;predict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x_test&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argmax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y_test&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argmax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y_pred&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10000&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;10000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argmax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;axis&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 返回沿轴axis最大值的索引。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用测试样本的数量代替&lt;code&gt;10000&lt;/code&gt;，输出的acc才是正确的结果。&lt;/p&gt;
&lt;p&gt;这个方法是使用二分类的时候才能使用的，label的个数多于2就不能使用。&lt;/p&gt;
&lt;h2 id="参考"&gt;参考
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://stackoverflow.com/questions/42081257/keras-binary-crossentropy-vs-categorical-crossentropy-performance" target="_blank" rel="noopener"
&gt;https://stackoverflow.com/questions/42081257/keras-binary-crossentropy-vs-categorical-crossentropy-performance&lt;/a&gt;&lt;/p&gt;</description></item></channel></rss>