<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docker on Svtter's Blog</title><link>https://svtter.cn/tags/docker/</link><description>Recent content in Docker on Svtter's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 13 Dec 2025 11:02:40 +0800</lastBuildDate><atom:link href="https://svtter.cn/tags/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>谨慎使用新兴开源软件</title><link>https://svtter.cn/p/%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8%E6%96%B0%E5%85%B4%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/</link><pubDate>Sat, 13 Dec 2025 11:02:40 +0800</pubDate><guid>https://svtter.cn/p/%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8%E6%96%B0%E5%85%B4%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/</guid><description>&lt;img src="https://svtter.cn/p/%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8%E6%96%B0%E5%85%B4%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/pics/background.png" alt="Featured image of post 谨慎使用新兴开源软件" /&gt;&lt;p&gt;最近我在 dify/langchain 上翻车了，得出这个结论。&lt;/p&gt;
&lt;h2 id="追溯"&gt;追溯
&lt;/h2&gt;&lt;p&gt;大概7个月前，我部署了开源的 dify 到服务器，通过官方的 docker compose 启动了实例。但是最近，由于 Dify 代码节点的沙箱逃逸漏洞（CVE-2025-3466），被 webshell 提权，植入了门罗币挖矿程序。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://svtter.cn/p/%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8%E6%96%B0%E5%85%B4%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/pics/danger-ip.png"
width="2553"
height="462"
srcset="https://svtter.cn/p/%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8%E6%96%B0%E5%85%B4%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/pics/danger-ip_hu_dbeb3947f178aac9.png 480w, https://svtter.cn/p/%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8%E6%96%B0%E5%85%B4%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/pics/danger-ip_hu_2c824746f741f4ac.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="552"
data-flex-basis="1326px"
&gt;&lt;/p&gt;
&lt;p&gt;好在，这次被提权之后，入侵者做的事情不多，并且入侵的是 docker container，损失可控。&lt;/p&gt;
&lt;h2 id="cve-2025-3466-详情"&gt;CVE-2025-3466 详情
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;CVE编号&lt;/strong&gt;: CVE-2025-3466
&lt;strong&gt;发布日期&lt;/strong&gt;: 2025年7月7日
&lt;strong&gt;CVSS评分&lt;/strong&gt;: 9.8 (严重)
&lt;strong&gt;影响版本&lt;/strong&gt;: langgenius/dify 1.1.0 - 1.1.2
&lt;strong&gt;修复版本&lt;/strong&gt;: 1.1.3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;漏洞描述&lt;/strong&gt;:
Dify 的代码节点（code node）存在沙箱逃逸漏洞，允许攻击者通过覆盖全局 JavaScript 函数（如 &lt;code&gt;parseInt&lt;/code&gt;）来绕过沙箱安全限制，从而以完整 root 权限执行任意代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;攻击流程&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;攻击者在代码节点的输入中构造恶意 payload&lt;/li&gt;
&lt;li&gt;恶意代码在沙箱限制实施前覆盖全局 JavaScript 函数&lt;/li&gt;
&lt;li&gt;利用被覆盖的函数绕过安全检查&lt;/li&gt;
&lt;li&gt;执行任意命令，获取容器完整控制权&lt;/li&gt;
&lt;li&gt;植入 webshell 后门和门罗币挖矿程序&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;影响范围&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未经授权访问 secret keys 和 API keys&lt;/li&gt;
&lt;li&gt;访问内部网络服务器&lt;/li&gt;
&lt;li&gt;在 dify.ai 系统内横向移动&lt;/li&gt;
&lt;li&gt;完全接管服务器控制权&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;相关链接&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="https://nvd.nist.gov/vuln/detail/cve-2025-3466" target="_blank" rel="noopener"
&gt;NVD 详情&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://github.com/advisories/GHSA-x53g-q9xm-rf4m" target="_blank" rel="noopener"
&gt;GitHub Advisory GHSA-x53g-q9xm-rf4m&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从这个角度看，保护服务器安全，几个关键的因素不可少。&lt;/p&gt;
&lt;h2 id="个人服务器安全"&gt;个人服务器安全
&lt;/h2&gt;&lt;p&gt;从安全角度来说，个人服务器有几个事情是一定要做的。第一个事情就是尽可能不要使用密码。例如 ssh 密码。&lt;/p&gt;
&lt;h3 id="ssh-密码"&gt;ssh 密码
&lt;/h3&gt;&lt;p&gt;必须禁用密码登录。ssh 密码破解起来相对容易，如果密码简单，或者用户自行修改密码，使用了简单的密码，那么服务器就会被入侵。&lt;/p&gt;
&lt;p&gt;如果使用 Debian/Linux，那么关闭密码登录和关闭 root 登录是必须的：&lt;/p&gt;
&lt;p&gt;使用的软件越少，攻击者的攻击面就越窄。一旦你的服务器上只暴露了 nginx，和 80 端口，22 端口（ssh）都没开，那么攻击者能攻击的面就只有 nginx 相关的内容。&lt;/p&gt;
&lt;h3 id="使用-rootless-docker"&gt;使用 rootless docker
&lt;/h3&gt;&lt;p&gt;使用容器技术相当于在云服务商的基础上进一步做虚拟化。&lt;/p&gt;
&lt;p&gt;使用 rootless docker 可以进一步限制容器的权限，即使容器被攻破，攻击者也无法直接获得宿主机的 root 权限。这是最后一道防线。&lt;/p&gt;
&lt;h3 id="限制容器的网络访问"&gt;限制容器的网络访问
&lt;/h3&gt;&lt;p&gt;大多数服务并不需要无限制的外网访问权限。合理配置容器的网络策略，限制不必要的网络访问，可以大大降低攻击面。&lt;/p&gt;
&lt;p&gt;例如，很多服务只需要访问数据库或者内部服务，根本不需要访问外网。如果容器没有外网访问权限，即使被攻破，攻击者也无法下载挖矿程序或者 C2 服务器进行通信。&lt;/p&gt;
&lt;h2 id="如何谨慎使用开源软件"&gt;如何谨慎使用开源软件
&lt;/h2&gt;&lt;p&gt;这次事件让我反思，在使用新兴开源软件时需要注意以下几点：&lt;/p&gt;
&lt;h3 id="选择成熟的项目"&gt;选择成熟的项目
&lt;/h3&gt;&lt;p&gt;查看项目的 star 数、commit 频率、issue 处理情况。如果一个项目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Star 数很少（少于几百）&lt;/li&gt;
&lt;li&gt;最近几个月没有更新&lt;/li&gt;
&lt;li&gt;大量未解决的 issue&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么使用这个项目的风险就很高。&lt;/p&gt;
&lt;h3 id="审查依赖关系"&gt;审查依赖关系
&lt;/h3&gt;&lt;p&gt;开源软件往往依赖大量的第三方库。像这次事件中的 Dify 就存在严重的代码节点沙箱逃逸漏洞。在部署前，最好能够：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查看项目的依赖树&lt;/li&gt;
&lt;li&gt;检查是否有已知漏洞&lt;/li&gt;
&lt;li&gt;定期更新依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="定期更新和安全扫描"&gt;定期更新和安全扫描
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;定期检查 CVE 数据库&lt;/li&gt;
&lt;li&gt;使用工具如 &lt;code&gt;snyk&lt;/code&gt;、&lt;code&gt;trivy&lt;/code&gt; 进行依赖漏洞扫描&lt;/li&gt;
&lt;li&gt;及时更新到修复了漏洞的版本&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="限制权限"&gt;限制权限
&lt;/h3&gt;&lt;p&gt;即使你信任某个开源软件，也应该给它最小的权限：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要给容器 privileged 权限&lt;/li&gt;
&lt;li&gt;限制容器的资源使用（CPU、内存）&lt;/li&gt;
&lt;li&gt;使用只读文件系统（如果可能）&lt;/li&gt;
&lt;li&gt;不要把宿主机的敏感目录挂载到容器中&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="监控和告警"&gt;监控和告警
&lt;/h2&gt;&lt;p&gt;安全是一个持续的过程，不能仅仅依靠预防。建立完善的监控和告警机制至关重要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监控系统资源使用情况（CPU、内存、磁盘IO异常可能表明有挖矿程序）&lt;/li&gt;
&lt;li&gt;监控网络流量（异常的出站连接）&lt;/li&gt;
&lt;li&gt;监控进程列表（异常的进程）&lt;/li&gt;
&lt;li&gt;设置日志告警（例如失败的登录尝试）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="总结"&gt;总结
&lt;/h2&gt;&lt;p&gt;开源软件为我们提供了巨大的便利，但也带来了安全风险。这次事件虽然损失不大，但给了我一个重要的教训：&lt;/p&gt;
&lt;p&gt;不要盲目信任任何软件，尤其是新兴的开源项目。在使用前要多做调查，在使用时要给最小权限，在使用后要持续监控和更新。&lt;/p&gt;
&lt;p&gt;服务器安全不是一劳永逸的，而是需要持续关注和维护的。&lt;/p&gt;</description></item><item><title>Docker Registry for Personal Docker Images</title><link>https://svtter.cn/p/docker-registry-for-personal-docker-images/</link><pubDate>Sun, 15 Jun 2025 16:43:47 +0800</pubDate><guid>https://svtter.cn/p/docker-registry-for-personal-docker-images/</guid><description>&lt;img src="https://svtter.cn/p/docker-registry-for-personal-docker-images/bg.jpg" alt="Featured image of post Docker Registry for Personal Docker Images" /&gt;&lt;p&gt;这篇文章中我尝试一种新的形式: 由我要提出问题，答案由 gpt 回答和撰写。另外，我会初步审核一下 gpt 回复的内容。&lt;/p&gt;
&lt;h2 id="亚马逊与-docker-镜像存储服务对比相关问题"&gt;亚马逊与 Docker 镜像存储服务对比相关问题
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;亚马逊美国Serverless服务器的价格是多少？&lt;/li&gt;
&lt;li&gt;亚马逊私有Docker Registry（如ECR）的价格是多少？&lt;/li&gt;
&lt;li&gt;Docker个人用户一个月的使用费用是多少？&lt;/li&gt;
&lt;li&gt;Docker个人版和其他付费版本（专业版、团队版、商业版）的区别是什么？&lt;/li&gt;
&lt;li&gt;对比亚马逊ECR和Docker Hub提供的镜像存储服务，用于存储即将过期的镜像及未来通过Docker Image部署函数服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="keypoints"&gt;Keypoints
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用 Amazon 可以让其他服务，例如 serverless 在不使用外部流量的前提下来获取 docker image.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="answer-by-gpt-doubao"&gt;Answer by GPT (doubao)
&lt;/h2&gt;&lt;p&gt;豆包：&lt;/p&gt;
&lt;h3 id="亚马逊与-docker-镜像存储服务对比文档"&gt;亚马逊与 Docker 镜像存储服务对比文档
&lt;/h3&gt;&lt;h4 id="一服务概述"&gt;&lt;strong&gt;一、服务概述&lt;/strong&gt;
&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1. **亚马逊ECR（Elastic Container Registry）**
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;亚马逊 AWS 提供的托管 Docker 镜像存储服务，深度集成 AWS 生态（如 Lambda、ECS、EC2 等），支持私有和公共镜像仓库，具备高可用性和安全管控能力。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2. **Docker Hub**
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Docker 官方提供的镜像存储服务，分为公共仓库和私有仓库，面向个人及企业用户，支持全球镜像分发和社区共享。&lt;/p&gt;
&lt;h4 id="二核心功能对比"&gt;&lt;strong&gt;二、核心功能对比&lt;/strong&gt;
&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;对比维度&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;亚马逊 ECR&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Docker Hub&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;存储类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;私有仓库为主（支持公共仓库，但需手动配置）&lt;/td&gt;
&lt;td&gt;公共仓库免费，私有仓库需付费升级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;集成能力&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;深度集成 AWS 服务（Lambda/ECS/CodePipeline）&lt;/td&gt;
&lt;td&gt;支持与 Docker Desktop、CI/CD 工具通用集成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;安全性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- 支持 AWS IAM 权限控制、加密（KMS）&lt;/td&gt;
&lt;td&gt;- 基础安全扫描（付费版增强）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;- 镜像签名、漏洞扫描（需配合 AWS Inspector）&lt;/td&gt;
&lt;td&gt;- 企业版支持 SSO、团队权限管理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;全球分发&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;多区域部署，自动复制镜像到指定区域&lt;/td&gt;
&lt;td&gt;全球镜像缓存节点，加速拉取&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;构建与自动化&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;支持与 CodeBuild 集成，自动构建镜像&lt;/td&gt;
&lt;td&gt;支持 Docker Cloud 自动构建（付费版）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;免费额度&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- 新用户首年 500MB 私有存储/月&lt;/td&gt;
&lt;td&gt;- 公共仓库无限，私有仓库免费版仅 1 个仓库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;过期镜像管理&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;需手动配置生命周期策略（删除旧版本镜像）&lt;/td&gt;
&lt;td&gt;付费版支持镜像过期策略设置&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="三费用对比以美国地区为例"&gt;&lt;strong&gt;三、费用对比（以美国地区为例）&lt;/strong&gt;
&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;服务项&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;亚马逊 ECR&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Docker Hub&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;存储费用&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- 超出 500MB 后：0.1 美元/GB/月&lt;/td&gt;
&lt;td&gt;- 私有仓库：专业版 5 美元/月起（含 2GB 存储）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;数据传输&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- 同区域内 AWS 服务间传输免费&lt;/td&gt;
&lt;td&gt;- 公共仓库拉取免费，私有仓库按流量计费&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;镜像拉取限制&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;无明确限制（按需付费）&lt;/td&gt;
&lt;td&gt;- 免费版：匿名用户每 6 小时 100 次拉取&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;- 专业版：5000 次/天，团队版无限制&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="四适用场景建议"&gt;&lt;strong&gt;四、适用场景建议&lt;/strong&gt;
&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1. **选择亚马逊ECR的场景**
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;已使用 AWS 生态&lt;/strong&gt;：如计划通过 Lambda 部署函数服务，ECR 可直接与 Lambda 集成，简化部署流程，无需额外配置网络或认证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高安全需求&lt;/strong&gt;：依赖 AWS IAM 权限体系，需镜像加密、细粒度访问控制（如仅限特定 AWS 账号访问）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多区域部署&lt;/strong&gt;：需将镜像自动同步到不同 AWS 区域，降低函数服务部署的网络延迟。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2. **选择Docker Hub的场景**
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;轻量级个人/团队项目&lt;/strong&gt;：公共仓库适合开源协作，私有仓库专业版（5 美元/月）性价比高，适合小规模镜像存储。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跨平台兼容性&lt;/strong&gt;：不依赖特定云服务商，支持本地开发与多云部署（如 AWS、Azure、GCP）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;社区资源依赖&lt;/strong&gt;：需直接拉取社区公共镜像（如官方 Docker 镜像），或需要通过 Docker CLI 快速管理镜像。&lt;/p&gt;
&lt;h4 id="五针对函数服务部署的建议"&gt;&lt;strong&gt;五、针对函数服务部署的建议&lt;/strong&gt;
&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1. **当前过期镜像存储**
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若镜像用于 AWS Lambda，优先选择 ECR，可通过生命周期策略自动清理旧版本，避免冗余存储费用。&lt;/p&gt;
&lt;p&gt;若镜像为通用型（非 AWS 专属），Docker Hub 专业版可设置私有仓库存储，并标记过期镜像为“存档”状态，节省空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2. **未来函数服务部署**
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;AWS Lambda 集成&lt;/strong&gt;：使用 ECR 存储镜像，通过 Lambda 控制台直接关联 ECR 仓库，实现代码更新自动部署（需配置 CodePipeline 触发器）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跨云或本地部署&lt;/strong&gt;：Docker Hub 私有仓库配合 Docker Compose 或 Kubernetes，支持多环境一致性部署，适合需要灵活迁移的场景。&lt;/p&gt;
&lt;h4 id="六总结"&gt;&lt;strong&gt;六、总结&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;亚马逊 ECR&lt;/strong&gt;：适合深度绑定 AWS 的企业级用户，安全与集成能力强，费用按存储和流量按需计算。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker Hub&lt;/strong&gt;：适合个人开发者、中小团队或跨云场景，付费版功能均衡，性价比高。
根据您的需求（存储过期镜像+函数服务部署），若已使用 AWS 生态，ECR 是更优选择；若追求通用性和成本控制，Docker Hub 专业版可满足基础需求。&lt;/p&gt;
&lt;h2 id="結論"&gt;結論
&lt;/h2&gt;&lt;p&gt;完全可以使用 Docker 的私人倉庫作為自己的主力倉庫。Docker 私人仓库价格相对划算，在使用 aws 或者 tencent cloud 的时候，完全可以配置一个合适的代理来拉取相关的镜像。或者使用 docker login 登录之后再进行拉取。&lt;/p&gt;</description></item><item><title>Heroku 的开源平替</title><link>https://svtter.cn/p/heroku-%E7%9A%84%E5%BC%80%E6%BA%90%E5%B9%B3%E6%9B%BF/</link><pubDate>Tue, 06 May 2025 21:49:42 +0800</pubDate><guid>https://svtter.cn/p/heroku-%E7%9A%84%E5%BC%80%E6%BA%90%E5%B9%B3%E6%9B%BF/</guid><description>&lt;img src="https://svtter.cn/p/heroku-%E7%9A%84%E5%BC%80%E6%BA%90%E5%B9%B3%E6%9B%BF/bg.png" alt="Featured image of post Heroku 的开源平替" /&gt;&lt;p&gt;近期出现了大量的 heroku 平替。这些替代品或多或少的支持了各种大型企业在内部构建自己的 PaaS 平台。&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://www.heroku.com/" target="_blank" rel="noopener"
&gt;Heroku&lt;/a&gt; 是一个用于 PaaS (Platform as a Service)，可以用于快速部署应用系统，平台的技术负责人是 Ruby 编程语言的创造者松本行弘。母公司是 Salesforce。&lt;/p&gt;
&lt;p&gt;PaaS 最大的好处就是不用自己考虑太多操作系统的事情，节省了运维的时间。而且如果配置得当，还能获得较好的监控等系统。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 Docker 的替代品如下：
&lt;ul&gt;
&lt;li&gt;dokku star: 30.4k&lt;/li&gt;
&lt;li&gt;coolify star: 40.9k&lt;/li&gt;
&lt;li&gt;dokploy star: 19.8k&lt;/li&gt;
&lt;li&gt;tsuru star: 5.1k&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之所以这些平台如雨后春笋，可能是因为 docker 的崛起，虚拟机管理变成了容器管理，而且有了相对简单的接口，人们可以在这个基础上进行二次开发。
我目前使用的是 coolify，感觉还不错。但是近期似乎没有怎么更新。我也在考虑使用更加方便的系统。
从稳定性上看，coolify 的稳定性是基于 docker 稳定性的，所以不用太担心 web 访问的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 kubernetes 的工具也不少。
&lt;ul&gt;
&lt;li&gt;例如 &lt;a class="link" href="https://docs.lagoon.sh/installing-lagoon/install-harbor/" target="_blank" rel="noopener"
&gt;lagoon&lt;/a&gt;；
&lt;ul&gt;
&lt;li&gt;依赖 harbor&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Kubernetes 上的系统部署会相对麻烦一些，需要配置多个组件。如果支持 helm chart，部署还会方便一些。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，经验之谈，基于 golang 的开源项目往往质量相对会高一些。（但不绝对）。&lt;/p&gt;</description></item><item><title>Config devcontainer.md</title><link>https://svtter.cn/p/config-devcontainer.md/</link><pubDate>Wed, 26 Mar 2025 20:17:47 +0800</pubDate><guid>https://svtter.cn/p/config-devcontainer.md/</guid><description>&lt;img src="https://svtter.cn/p/config-devcontainer.md/image.png" alt="Featured image of post Config devcontainer.md" /&gt;&lt;p&gt;有时候，尽管我们启动一个 docker 环境可以执行代码，但是 vscode 补全未能生效。&lt;/p&gt;
&lt;p&gt;这是由于相关的库都在 container 中，我们 vscode 一般是运行在 host os 上。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们可以在项目根目录下，使用 docker-compose.yml 来创建一个开发环境。&lt;/p&gt;
&lt;p&gt;然后，创建一个&lt;code&gt;.devcontainer/devcontainer.json&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;例如，如果你要开发 python 的程序，可以使用下面的 &lt;code&gt;.devcontainer/devcontainer.json&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-json" data-lang="json"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;MyPython&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;dockerComposeFile&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;../docker-compose.yml&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;service&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;notebook&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;service&lt;/span&gt; &lt;span class="err"&gt;in&lt;/span&gt; &lt;span class="err"&gt;your&lt;/span&gt; &lt;span class="err"&gt;docker-compose.yml&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;workspaceFolder&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;/app&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;shutdownAction&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;none&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;customizations&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;vscode&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;extensions&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;ms-python.python&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;ms-azuretools.vscode-docker&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;tamasfe.even-better-toml&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;charliermarsh.ruff&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;ms-python.black-formatter&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;ms-toolsai.jupyter&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如此一来，就可以启动一个安装好相关环境的『子』系统了。&lt;/p&gt;
&lt;p&gt;深入阅读：&lt;a class="link" href="https://blog.roboflow.com/nvidia-docker-vscode-pytorch/#installing-docker-for-machine-learning" target="_blank" rel="noopener"
&gt;Develop like a Pro with NVIDIA + Docker + VS Code + PyTorch&lt;/a&gt;。&lt;/p&gt;</description></item><item><title>A Docker Image for Computer Vision</title><link>https://svtter.cn/p/a-docker-image-for-computer-vision/</link><pubDate>Wed, 26 Mar 2025 19:57:22 +0800</pubDate><guid>https://svtter.cn/p/a-docker-image-for-computer-vision/</guid><description>&lt;img src="https://svtter.cn/p/a-docker-image-for-computer-vision/image.png" alt="Featured image of post A Docker Image for Computer Vision" /&gt;&lt;p&gt;我们在调试深度学习代码的时候，经常会因为环境的问题而头痛。&lt;/p&gt;
&lt;p&gt;为了方便调试，把 pytorch cuda 等环境打成 docker image 是一个很不错的选择。&lt;/p&gt;
&lt;h2 id="为什么"&gt;为什么？
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;时间节省：反复配置和调整版本会浪费时间，导致花费大量的时间在 ops 的工作上。&lt;/li&gt;
&lt;li&gt;环境稳定：docker image 构建之后是静态的，直接拉取即可。&lt;/li&gt;
&lt;li&gt;迁移方便：可以在不同机器上迁移已经配置好的环境&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="如何构建"&gt;如何构建
&lt;/h2&gt;&lt;p&gt;这是一个 Docker Image 示例，用于将深度学习环境打包：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Dockerfile" data-lang="Dockerfile"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# 可以改成你需要的 pytorch 版本&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;pytorch/pytorch:2.4.1-cuda11.8-cudnn9-devel&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 这些是常用的包&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;RUN&lt;/span&gt; apt-get update &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get install git zsh ffmpeg libsm6 libxext6 -y &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get clean &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm -rf /var/lib/apt/lists/*&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;WORKDIR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;/app&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 放在代码库的根目录下，可以安装 requirements.txt&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;COPY&lt;/span&gt; requirements.txt .&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;RUN&lt;/span&gt; pip install -r requirements.txt&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# install jupyterlab&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;RUN&lt;/span&gt; pip install jupyterlab&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# COPY . .&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 使用 jupyterlab 托管，可以快速启动，token 是`yourtoken`。如果你在公网使用，要考虑使用更复杂的 token。&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;CMD&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;jupyter&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;lab&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;--ip=0.0.0.0&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;--port=8888&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;--no-browser&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;--allow-root&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;--NotebookApp.token=yourtoken&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这个示例安装了一些基础的类库，通过 pip 即可安装 &lt;code&gt;opencv-python&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;将&lt;code&gt;Dockerfile&lt;/code&gt;放在目录下，然后可以使用&lt;code&gt;docker compose&lt;/code&gt;启动。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-yaml" data-lang="yaml"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nt"&gt;services&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;notebook&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;build&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;context&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l"&gt;.&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;dockerfile&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l"&gt;Dockerfile&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;volumes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c"&gt;# 还可以挂载自己需要的 dataset&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;- &lt;span class="l"&gt;.:/app&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;- &lt;span class="l"&gt;~/.ssh:/root/.ssh&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c"&gt;# 支持 ssh&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;- &lt;span class="m"&gt;8888&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;8888&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;shm_size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;32gb&amp;#39;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;deploy&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;resources&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;reservations&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;devices&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;- &lt;span class="nt"&gt;driver&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l"&gt;nvidia&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l"&gt;all&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;capabilities&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="l"&gt;gpu]&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;启动命令是：&lt;code&gt;docker compose up -d&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="从-dockerhub-上下载"&gt;从 Dockerhub 上下载
&lt;/h2&gt;&lt;p&gt;为了方便大家直接使用，我将这个镜像打包，并且上传到了 dockerhub。下载命令是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;docker pull svtter/debian-pytorch
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;源代码可以从这里获得：&lt;/p&gt;
&lt;script src="https://tarptaeya.github.io/repo-card/repo-card.js"&gt;&lt;/script&gt;
&lt;!-- inside body, where you want to create the card --&gt;
&lt;div class="repo-card" data-repo="Svtter/debian-pytorch"&gt;&lt;/div&gt;
&lt;h2 id="在-runpod-上使用"&gt;在 Runpod 上使用
&lt;/h2&gt;&lt;p&gt;为了方便大家使用，我在 Runpod 上创建了一个模板。&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://console.runpod.io/deploy?template=m0shpm3vgg&amp;amp;ref=g5qp1x9x" target="_blank" rel="noopener"
&gt;https://console.runpod.io/deploy?template=m0shpm3vgg&amp;ref=g5qp1x9x&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用这个模板就可以直接使用这个 image 了。&lt;/p&gt;</description></item><item><title>Create a Never Stop Container.md</title><link>https://svtter.cn/p/create-a-never-stop-container.md/</link><pubDate>Fri, 14 Mar 2025 16:45:58 +0800</pubDate><guid>https://svtter.cn/p/create-a-never-stop-container.md/</guid><description>&lt;img src="https://svtter.cn/p/create-a-never-stop-container.md/background.png" alt="Featured image of post Create a Never Stop Container.md" /&gt;&lt;p&gt;有时候我们需要启动一个不停止的容器，来调试我们的应用，或者使用 devcontainer。&lt;/p&gt;
&lt;p&gt;如果我们想在 &lt;code&gt;Dockerfile&lt;/code&gt; 中完成这个事情，我们可以添加这个&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Dockerfile" data-lang="Dockerfile"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;...&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 其他内容&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;ENTRYPOINT&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;tail&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;-f&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;/dev/null&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果是 &lt;code&gt;docker-compose.yml&lt;/code&gt;，我们可以这样做&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-yaml" data-lang="yaml"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nt"&gt;services&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;your-app&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;entrypoint&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;tail&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;-f&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;/dev/null&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如此一来，这个容器就不会停止了。&lt;/p&gt;</description></item><item><title>Compile Latex Local.md</title><link>https://svtter.cn/p/compile-latex-local.md/</link><pubDate>Mon, 17 Feb 2025 16:39:50 +0800</pubDate><guid>https://svtter.cn/p/compile-latex-local.md/</guid><description>&lt;p&gt;我们有时候希望在本地而不是 overleaf 上编译 latex 文件。这篇文章提供了一个方法。&lt;/p&gt;
&lt;p&gt;我们可以用 Docker 来构建一个编译环境。Dockerfile 如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Dockerfile" data-lang="Dockerfile"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 使用 TeXLive 官方镜像作为基础镜像&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;texlive/texlive:latest&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 安装必要的包&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;RUN&lt;/span&gt; apt-get update &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get install -y &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="se"&gt;&lt;/span&gt; make &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="se"&gt;&lt;/span&gt; git &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="se"&gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm -rf /var/lib/apt/lists/*&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 设置工作目录&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;WORKDIR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;/paper&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 复制论文源文件到容器中&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;COPY&lt;/span&gt; . .&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 设置默认命令&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;CMD&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;latexmk&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;-pdf&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;0_main.tex&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;构建镜像：&lt;code&gt;docker build -t paper .&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;构建PDF: &lt;code&gt;docker run --rm -v $(pwd):/paper paper&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;构建命令可以自己修改。比如你的主文件是&lt;code&gt;main.tex&lt;/code&gt;，就可以修改成&lt;code&gt;CMD [&amp;quot;latexmk&amp;quot;, &amp;quot;-pdf&amp;quot;, &amp;quot;0_main.tex&amp;quot;]&lt;/code&gt;。&lt;/p&gt;</description></item><item><title>使用一个基础镜像来避免反复安装依赖项</title><link>https://svtter.cn/p/%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E6%9D%A5%E9%81%BF%E5%85%8D%E5%8F%8D%E5%A4%8D%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E9%A1%B9/</link><pubDate>Tue, 27 Aug 2024 18:04:54 +0800</pubDate><guid>https://svtter.cn/p/%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E6%9D%A5%E9%81%BF%E5%85%8D%E5%8F%8D%E5%A4%8D%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E9%A1%B9/</guid><description>&lt;p&gt;很多时候，构建 docker 镜像的速度很慢，尤其是当我们的基础依赖发生改变之后。为了解决这个问题，我们应该在实际运行的镜像之前，增加一个 venv 的基础镜像。&lt;/p&gt;
&lt;p&gt;如果我们想要构建一个前端的镜像，那么不可避免的要下载和安装使用 npm 包。我们可以构建一个基础镜像，名称为 &lt;code&gt;frontend-base&lt;/code&gt;。
镜像的内容&lt;code&gt;dockerfile.base&lt;/code&gt;如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-dockerfile" data-lang="dockerfile"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; FROM node:20 as build-stage&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt; WORKDIR /app&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt; ENV &lt;span class="nv"&gt;ELECTRON_MIRROR&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;https://npmmirror.com/mirrors/electron/&amp;#34;&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt; COPY pnpm-lock.yaml package.json /app/&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt; RUN npm install -g pnpm &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; pnpm install&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt; COPY . .&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt; RUN pnpm run build:vite&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;运行命令构建镜像：&lt;code&gt;docker build -f Dockerfile.base -t svtter/frontend-base:latest .&lt;/code&gt;
如此一来，我们可以构建好一个&lt;code&gt;frontend-base:latest&lt;/code&gt;镜像。
然后，我们再构建&lt;code&gt;frontend:latest&lt;/code&gt;镜像，作为我们实际部署应用的镜像。 &lt;code&gt;dockerfile&lt;/code&gt;是这样的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-dockerfile" data-lang="dockerfile"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# FROM node:20 as build-stage&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;svtter/cathodic-frontend-base:latest&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;as&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;build-stage&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;WORKDIR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;/app&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;ENV&lt;/span&gt; &lt;span class="nv"&gt;ELECTRON_MIRROR&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;https://npmmirror.com/mirrors/electron/&amp;#34;&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;COPY&lt;/span&gt; pnpm-lock.yaml package.json /app/&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;RUN&lt;/span&gt; pnpm install&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;COPY&lt;/span&gt; . .&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;RUN&lt;/span&gt; pnpm run build:vite&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;nginx:1.25.1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;as&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;prod&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;COPY&lt;/span&gt; --from&lt;span class="o"&gt;=&lt;/span&gt;build-stage /app/src/out /usr/share/nginx/html&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;注意：因为我的代码里使用了 electron，所以为了速度更快，我使用了&lt;code&gt;ELECTRON_MIRROR&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;这里的构建命令是：&lt;code&gt;docker build -t svtter/frontend:latest .&lt;/code&gt;
这样一来，我们可以避免几个问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果基础的依赖有改变，在 venv 的基础上，pnpm 可以减少 npm 包的反复下载。&lt;/li&gt;
&lt;li&gt;一段时间后，我们可以重新构建 &lt;code&gt;frontend-base&lt;/code&gt;，来减少在 &lt;code&gt;frontend&lt;/code&gt; 中包的下载。&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Using Kind to Play with K8s</title><link>https://svtter.cn/p/using-kind-to-play-with-k8s/</link><pubDate>Wed, 12 Jun 2024 11:09:49 +0800</pubDate><guid>https://svtter.cn/p/using-kind-to-play-with-k8s/</guid><description>&lt;p&gt;如果直接使用 kubernetes 的线上版本进行调试，需要资源太多了。使用 minikube 有时候又无法启动集群。
因此，开发者可以考虑使用 &lt;a class="link" href="https://kind.sigs.k8s.io/docs/user/quick-start/" target="_blank" rel="noopener"
&gt;Kind&lt;/a&gt; 来部署测试 Kubernetes。&lt;/p&gt;
&lt;p&gt;This article is about using Kind to create a Kubernetes (K8s) cluster and debug it.&lt;/p&gt;
&lt;p&gt;By default, Kind does not support load balancers. If you want to test your apps, use &lt;code&gt;NodePort&lt;/code&gt; or &lt;code&gt;ClusterIP&lt;/code&gt; instead.&lt;/p&gt;
&lt;p&gt;Source code: &lt;a class="link" href="https://github.com/Svtter/example-code-for-kind" target="_blank" rel="noopener"
&gt;svtter/example-code-for-kind&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="using-nodeport-to-view-service"&gt;Using NodePort to View Service
&lt;/h2&gt;&lt;p&gt;Get the node&amp;rsquo;s IP to visit:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;(&lt;/span&gt;base&lt;span class="o"&gt;)&lt;/span&gt; ➜ cathodic kubectl get nodes -o wide
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIME
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;kind-control-plane Ready control-plane 22h v1.30.0 172.18.0.2 &amp;lt;none&amp;gt; Debian GNU/Linux &lt;span class="m"&gt;12&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;bookworm&lt;span class="o"&gt;)&lt;/span&gt; 6.1.0-18-amd64 containerd://1.7.15
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;View the service IP:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;(&lt;/span&gt;base&lt;span class="o"&gt;)&lt;/span&gt; ➜ cathodic kubectl get service nginx-service
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;NAME TYPE CLUSTER-IP EXTERNAL-IP PORT&lt;span class="o"&gt;(&lt;/span&gt;S&lt;span class="o"&gt;)&lt;/span&gt; AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;nginx-service NodePort 10.96.65.77 &amp;lt;none&amp;gt; 80:30160/TCP 26m
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Now, use &lt;code&gt;curl -L http://172.18.0.2:30160&lt;/code&gt; to visit the Nginx service.&lt;/p&gt;
&lt;h2 id="using-loadbalancer"&gt;Using LoadBalancer
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Install cloud-provider-kind via this &lt;a class="link" href="https://kind.sigs.k8s.io/docs/user/loadbalancer/" target="_blank" rel="noopener"
&gt;loadbalancer&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Start Kind, unlabel the node, and start &lt;code&gt;cloud-provider-kind&lt;/code&gt; according to this &lt;a class="link" href="https://github.com/kubernetes-sigs/cloud-provider-kind?tab=readme-ov-file#install" target="_blank" rel="noopener"
&gt;link&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>使用 Docker 构建前端应用</title><link>https://svtter.cn/p/%E4%BD%BF%E7%94%A8-docker-%E6%9E%84%E5%BB%BA%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/</link><pubDate>Sat, 04 Sep 2021 18:04:01 +0800</pubDate><guid>https://svtter.cn/p/%E4%BD%BF%E7%94%A8-docker-%E6%9E%84%E5%BB%BA%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/</guid><description>&lt;p&gt;docker compose 构建前端 app 是否容易，强烈建议中小企业采用这种方法。&lt;/p&gt;
&lt;p&gt;对于前后端分离的 WEB 应用，一般采用&lt;code&gt;npm run build&lt;/code&gt;的形式构建静态文件。
生成静态文件后，将静态文件放置到 nginx 的静态目录下。&lt;/p&gt;
&lt;p&gt;因此，我们可以根据这个特点，完成 nginx 镜像的构建。&lt;/p&gt;
&lt;p&gt;这个构建过程往往分成两步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构建前端的环境，并且生成静态文件&lt;/li&gt;
&lt;li&gt;构建&lt;code&gt;nginx&lt;/code&gt;镜像，将静态文件拷贝&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="dockerfile"&gt;Dockerfile
&lt;/h2&gt;&lt;p&gt;一个样例&lt;code&gt;Dockerfile&lt;/code&gt;如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;span class="lnt"&gt;22
&lt;/span&gt;&lt;span class="lnt"&gt;23
&lt;/span&gt;&lt;span class="lnt"&gt;24
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-dockerfile" data-lang="dockerfile"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# Stage 0, &amp;#34;build-stage&amp;#34;, based on Node.js, to build and compile the frontend&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;node:14&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;as&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;build-stage&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;WORKDIR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;/app&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 配置淘宝镜像&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;RUN&lt;/span&gt; yarn config &lt;span class="nb"&gt;set&lt;/span&gt; registry https://registry.npm.taobao.org/&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 复制前端依赖文件&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;COPY&lt;/span&gt; package.json /app/&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;RUN&lt;/span&gt; yarn install&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;COPY&lt;/span&gt; . /app&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;RUN&lt;/span&gt; yarn run build&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 复制 nginx 配置文件&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;COPY&lt;/span&gt; default.conf default.conf&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# Stage 1, based on Nginx, to have only the compiled app, ready for production with Nginx&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;nginx:1.18&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;COPY&lt;/span&gt; --from&lt;span class="o"&gt;=&lt;/span&gt;build-stage /app/dist/ /usr/share/nginx/html&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# Copy the default default.conf provided by tiangolo/node-frontend&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;COPY&lt;/span&gt; --from&lt;span class="o"&gt;=&lt;/span&gt;build-stage /app/default.conf /etc/nginx/conf.d/default.conf&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="k"&gt;CMD&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;nginx&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;-g&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;daemon off;&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;nginx 配置文件如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-nginx" data-lang="nginx"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kn"&gt;access_log&lt;/span&gt; &lt;span class="s"&gt;/dev/log&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kn"&gt;root&lt;/span&gt; &lt;span class="s"&gt;/usr/share/nginx/html&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id="启动应用"&gt;启动应用
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;构建前端镜像：&lt;code&gt;docker build -t frontend .&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;启动前端应用：&lt;code&gt;docker run -it -p 3000:80 -d frontend .&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样，我们在主机的&lt;code&gt;3000&lt;/code&gt;端口启动了&lt;code&gt;nginx&lt;/code&gt;，并且将前端的应用拷贝了进去。&lt;/p&gt;
&lt;p&gt;下一步，我们可以在此基础上构建整个应用。&lt;/p&gt;
&lt;p&gt;（未完待续）&lt;/p&gt;</description></item><item><title>使用 Docker swarm 构建 PostgreSQL 集群</title><link>https://svtter.cn/p/%E4%BD%BF%E7%94%A8-docker-swarm-%E6%9E%84%E5%BB%BA-postgresql-%E9%9B%86%E7%BE%A4/</link><pubDate>Sat, 01 Dec 2018 01:00:00 +0800</pubDate><guid>https://svtter.cn/p/%E4%BD%BF%E7%94%A8-docker-swarm-%E6%9E%84%E5%BB%BA-postgresql-%E9%9B%86%E7%BE%A4/</guid><description>&lt;blockquote&gt;
&lt;p&gt;又是一个渣翻，Copyright belongs to the original text。&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://info.crunchydata.com/blog/an-easy-recipe-for-creating-a-postgresql-cluster-with-docker-swarm" target="_blank" rel="noopener"
&gt;原文地址&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id="背景"&gt;背景
&lt;/h2&gt;&lt;p&gt;PostgreSQL 在 9.0 版本已经开始持续接收大量的增强，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;异步拓展&lt;/li&gt;
&lt;li&gt;同步拓展&lt;/li&gt;
&lt;li&gt;仲裁提交&lt;/li&gt;
&lt;li&gt;级联拓展&lt;/li&gt;
&lt;li&gt;逻辑拓展&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PostgreSQL 文档也提供了一个 overview 以及 不同拓展方法的比较。详见&lt;a href="https://www.postgresql.org/docs/current/different-replication-solutions.html" target="_blank" rel="noopener"&gt;PostgreSQL 集群策略比较&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用于部署 PostgreSQL 的拓展的主拓展的方法论，是一个重要的工具来为你的数据库集群创建高可用的环境。需要一个合适的部署策略来确保你的数据被保存到不同磁盘，以及不同的数据中心。&lt;/p&gt;
&lt;p&gt;拓展不是一个“安装然后忘记”的操作。在生产系统中，你想要确定你对实例有合适的监控，来了解你所有的在线的拓展，或者了解一个拓展有多少数据需要与主节点进行同步。&lt;/p&gt;
&lt;p&gt;当主节点配置好以后，安装就很容易了。但幸运的是，使用 Docker 可以使得这个过程更加轻松。&lt;/p&gt;
&lt;h2 id="环境安装"&gt;环境安装
&lt;/h2&gt;&lt;p&gt;想要部署这个环境，你至少需要 Docker 1.12版本。&lt;/p&gt;
&lt;p&gt;要想开始，提供一个 Docker 集群。例如，一个开发集群，你可以在每一个机器上加载 Dokcer，来使用 Swarm。这个方法将使用如下的架构：&lt;/p&gt;
&lt;img src="https://i2.wp.com/info.crunchydata.com/hs-fs/hubfs/diagram.png?w=625&amp;#038;ssl=1" alt="PostgreSQL Docker Swarm Architecture" data-recalc-dims="1" /&gt;
&lt;p&gt;每一个系统都需要安装 Docker 以及启动。&lt;/p&gt;
&lt;h2 id="swarm-安装"&gt;Swarm 安装
&lt;/h2&gt;&lt;p&gt;从1.12版本开始，Docker就已经集成了Swarm。&lt;/p&gt;
&lt;h2 id="容器编排"&gt;容器编排
&lt;/h2&gt;&lt;p&gt;高可用 PostgresSQL 集群配置需要两个以上的主机。主节点和从节点需要运行在不同的 worker 节点上，来使得可用性最高。&lt;/p&gt;
&lt;p&gt;为了部署 &lt;a href="https://github.com/CrunchyData/crunchy-containers/" target="_blank" rel="noopener"&gt;Crunchy PostgreSQL containers&lt;/a&gt; 到多个集群，你需要使用 node labels。&lt;/p&gt;
&lt;p&gt;标注主机对于使用 PostgreSQL 容器有几个好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将服务散步到许多 worker 上，来提高可用性&lt;/li&gt;
&lt;li&gt;主机可以针对读（从）写（主）操作进行优化（例如使用高性能磁盘）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;**记住：**对于PostgreSQL 10，主节点可以同时被允许读写，但是从节点仅仅允许被读。&lt;/p&gt;
&lt;p&gt;为了允许容器被放在指定的 worker 节点上，增加一个元数据标签到 Swarm 节点上。&lt;/p&gt;
&lt;pre&gt;node1_id=&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;$(&lt;/span&gt;docker node list &lt;span class="pl-k"&gt;|&lt;/span&gt; grep worker1 &lt;span class="pl-k"&gt;|&lt;/span&gt; awk &lt;span class="pl-pds"&gt;'&lt;/span&gt;{print $1}&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;span class="pl-pds"&gt;)&lt;/span&gt;&lt;/span&gt;
docker node update --label-add type=primary &lt;span class="pl-smi"&gt;${node1_id?}
&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;在上述例子中，一个被称为 primary 的标签，加入了 worker1。通过使用这个标签，我们可以应用一些约束到 Docker swarm 的 PostgreSQL Stack 部署上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：我们没有对从节点增加约束，我们可以简单的使用一条 inverse 约束：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;node.labels.type != primary&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="postgresql-stack-定义"&gt;PostgreSQL stack 定义
&lt;/h2&gt;&lt;p&gt;通过 Swarm 部署以及 worker 节点正确的标记，我们可以部署 PostgreSQL stack了。&lt;/p&gt;
&lt;p&gt;PostgreSQL stack 是通过一个主节点以及从节点组成的。下面是服务定义：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;docker-compose.yml&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;---
&lt;span class="pl-ent"&gt;version&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;3.3&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-ent"&gt;services&lt;/span&gt;:
&lt;span class="pl-ent"&gt;primary&lt;/span&gt;:
&lt;span class="pl-ent"&gt;hostname&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;primary&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-ent"&gt;image&lt;/span&gt;: &lt;span class="pl-s"&gt;crunchydata/crunchy-postgres:centos7-10.3-1.8.2&lt;/span&gt;
&lt;span class="pl-ent"&gt;environment&lt;/span&gt;:
- &lt;span class="pl-s"&gt;PGHOST=/tmp&lt;/span&gt;
- &lt;span class="pl-s"&gt;MAX_CONNECTIONS=10&lt;/span&gt;
- &lt;span class="pl-s"&gt;MAX_WAL_SENDERS=5&lt;/span&gt;
- &lt;span class="pl-s"&gt;PG_MODE=primary&lt;/span&gt;
- &lt;span class="pl-s"&gt;PG_PRIMARY_USER=primaryuser&lt;/span&gt;
- &lt;span class="pl-s"&gt;PG_PRIMARY_PASSWORD=password&lt;/span&gt;
- &lt;span class="pl-s"&gt;PG_DATABASE=testdb&lt;/span&gt;
- &lt;span class="pl-s"&gt;PG_USER=testuser&lt;/span&gt;
- &lt;span class="pl-s"&gt;PG_PASSWORD=password&lt;/span&gt;
- &lt;span class="pl-s"&gt;PG_ROOT_PASSWORD=password&lt;/span&gt;
- &lt;span class="pl-s"&gt;PG_PRIMARY_PORT=5432&lt;/span&gt;
&lt;span class="pl-ent"&gt;volumes&lt;/span&gt;:
- &lt;span class="pl-s"&gt;pg-primary-vol:/pgdata&lt;/span&gt;
&lt;span class="pl-ent"&gt;ports&lt;/span&gt;:
- &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;5432&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-ent"&gt;networks&lt;/span&gt;:
- &lt;span class="pl-s"&gt;crunchynet&lt;/span&gt;
&lt;span class="pl-ent"&gt;deploy&lt;/span&gt;:
&lt;span class="pl-ent"&gt;placement&lt;/span&gt;:
&lt;span class="pl-ent"&gt;constraints&lt;/span&gt;:
- &lt;span class="pl-s"&gt;node.labels.type == primary&lt;/span&gt;
- &lt;span class="pl-s"&gt;node.role == worker&lt;/span&gt;
&lt;span class="pl-ent"&gt;replica&lt;/span&gt;:
&lt;span class="pl-ent"&gt;image&lt;/span&gt;: &lt;span class="pl-s"&gt;crunchydata/crunchy-postgres:centos7-10.3-1.8.2&lt;/span&gt;
&lt;span class="pl-ent"&gt;environment&lt;/span&gt;:
- &lt;span class="pl-s"&gt;PGHOST=/tmp&lt;/span&gt;
- &lt;span class="pl-s"&gt;MAX_CONNECTIONS=10&lt;/span&gt;
- &lt;span class="pl-s"&gt;MAX_WAL_SENDERS=5&lt;/span&gt;
- &lt;span class="pl-s"&gt;PG_MODE=replica&lt;/span&gt;
- &lt;span class="pl-s"&gt;PG_PRIMARY_HOST=primary&lt;/span&gt;
- &lt;span class="pl-s"&gt;PG_PRIMARY_PORT=5432&lt;/span&gt;
- &lt;span class="pl-s"&gt;PG_PRIMARY_USER=primaryuser&lt;/span&gt;
- &lt;span class="pl-s"&gt;PG_PRIMARY_PASSWORD=password&lt;/span&gt;
- &lt;span class="pl-s"&gt;PG_DATABASE=testdb&lt;/span&gt;
- &lt;span class="pl-s"&gt;PG_USER=testuser&lt;/span&gt;
- &lt;span class="pl-s"&gt;PG_PASSWORD=password&lt;/span&gt;
- &lt;span class="pl-s"&gt;PG_ROOT_PASSWORD=password&lt;/span&gt;
&lt;span class="pl-ent"&gt;volumes&lt;/span&gt;:
- &lt;span class="pl-s"&gt;pg-replica-vol:/pgdata&lt;/span&gt;
&lt;span class="pl-ent"&gt;ports&lt;/span&gt;:
- &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;5432&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-ent"&gt;networks&lt;/span&gt;:
- &lt;span class="pl-s"&gt;crunchynet&lt;/span&gt;
&lt;span class="pl-ent"&gt;deploy&lt;/span&gt;:
&lt;span class="pl-ent"&gt;placement&lt;/span&gt;:
&lt;span class="pl-ent"&gt;constraints&lt;/span&gt;:
- &lt;span class="pl-s"&gt;node.labels.type != primary&lt;/span&gt;
- &lt;span class="pl-s"&gt;node.role == worker&lt;/span&gt;
&lt;span class="pl-ent"&gt;networks&lt;/span&gt;:
&lt;span class="pl-ent"&gt;crunchynet&lt;/span&gt;:
&lt;span class="pl-ent"&gt;volumes&lt;/span&gt;:
&lt;span class="pl-ent"&gt;pg-primary-vol&lt;/span&gt;:
&lt;span class="pl-ent"&gt;pg-replica-vol&lt;/span&gt;:&lt;/pre&gt;
&lt;p&gt;注意，主服务定义了一个 hostname，但是 replica 服务没有。Replica 需要一个 hostname 来启动 replication。通过提供一个静态的 hostname 给主节点，replica就可以连接主节点，而不需要发现主容器。&lt;/p&gt;
&lt;p&gt;replica，没有一个 hostname，这允许 replica 服务拓展到多个节点。（待会儿展示一下）。&lt;/p&gt;
&lt;p&gt;primary 和 replica 服务的主要区别，是 PG_MODE 环境变量。这个变量配置容器是主节点，还是从节点。&lt;/p&gt;
&lt;h2 id="部署-stack"&gt;部署 STACK
&lt;/h2&gt;&lt;p&gt;保存这个文件到 _docker-compose.yml _之后，我们可以通过 Docker 进行部署了。&lt;/p&gt;
&lt;pre&gt;docker stack deploy --compose-file=./docker-compose.yml pg-stack&lt;/pre&gt;
&lt;p&gt;这个 stack 部署，将会创建一个 PostgreSQL 集群，就像是下图一样：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src="https://i0.wp.com/info.crunchydata.com/hs-fs/hubfs/Diagram4.png?w=625&amp;#038;ssl=1" alt="PostgreSQL Docker Swarm Primary Replica Cluster" data-recalc-dims="1" /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="测试集群"&gt;测试集群
&lt;/h2&gt;&lt;p&gt;检查服务是否运行，运行下面的命令：&lt;/p&gt;
&lt;pre&gt;docker service ls
docker service ps pg-stack_primary
docker service ps pg-stack_replica&lt;/pre&gt;
&lt;p&gt;如果想要提升 replicas 的数量，运行下列命令：&lt;/p&gt;
&lt;pre&gt;docker service scale pg-stack_replica=2
docker service ps pg-stack_replica&lt;/pre&gt;
&lt;p&gt;为了确保 replicas 是流式的，在 worker1 节点上查询 PostgreSQL 主节点，使用下列命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker exec -it $(docker ps -q) psql -U postgres -x -c 'table pg_stat_replication' postgres
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="示例代码"&gt;示例代码
&lt;/h2&gt;&lt;p&gt;下面是实例代码：&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://github.com/CrunchyData/crunchy-containers/tree/master/examples/docker/swarm-service" target="_blank" rel="noopener"
&gt;https://github.com/CrunchyData/crunchy-containers/tree/master/examples/docker/swarm-service&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="结论"&gt;结论
&lt;/h2&gt;&lt;p&gt;Docker 以及 Docker swarm 提供了工具，来使得容器部署进入了更高的层次。我们希望这个提议证明了 PostgreSQL 集群是如何的容易部署。&lt;/p&gt;</description></item><item><title>使用Docker时遇到的sitemap问题</title><link>https://svtter.cn/p/%E4%BD%BF%E7%94%A8docker%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84sitemap%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 27 Dec 2017 01:00:00 +0800</pubDate><guid>https://svtter.cn/p/%E4%BD%BF%E7%94%A8docker%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84sitemap%E9%97%AE%E9%A2%98/</guid><description>&lt;p&gt;这两天感觉博客访问量已经不能靠用嘴宣传了，于是决定做一下sitemap，但是发现django自带的sitemap生成器存在这样的问题：生成的sitemap是依照container的hostname来显示的。&lt;/p&gt;
&lt;p&gt;为此我查询了一下其他人是怎么搞的，发现他们都把nginx和django放在一个容器下——但是如此构建不仅麻烦，似乎违背了docker的构建思路，在一个container里面放了多个进程。因此，我认为下面的方案是合理的。&lt;/p&gt;
&lt;h2 id="解决方案"&gt;解决方案
&lt;/h2&gt;&lt;h3 id="enabling-the-sites-framework"&gt;Enabling the sites framework
&lt;/h3&gt;&lt;p&gt;To enable the sites framework, follow these steps:&lt;/p&gt;
&lt;p&gt;Add ‘django.contrib.sites’ to your INSTALLED_APPS setting.&lt;/p&gt;
&lt;h3 id="define-a-site_id-setting"&gt;Define a SITE_ID setting:
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;SITE_ID = 1&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="run-migrate"&gt;Run migrate.
&lt;/h3&gt;&lt;p&gt;django.contrib.sites registers a post_migrate signal handler which creates a default site named example.com with the domain example.com. This site will also be created after Django creates the test database. To set the correct name and domain for your project, you can use a data migration.&lt;/p&gt;
&lt;p&gt;In order to serve different sites in production, you’d create a separate settings file with each SITE_ID (perhaps importing from a common settings file to avoid duplicating shared settings) and then specify the appropriate DJANGO_SETTINGS_MODULE for each site.&lt;/p&gt;
&lt;div class="codehilite"&gt;
&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;django.contrib.sites.models&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Site&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Site&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;objects&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;all&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;domain&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;myveryspecialdomain.com&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;My Special Site Name&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;save&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;代码写多了，对于Flask和Django也就十分释然了。两个东西都是利器，针对的东西不是很相同；编程语言也是，都有自己擅长的部分，如果你非要用某种编程语言花很大的力气去做一件小事，除非你是geek而且有追求，并且没有deadline在旁边催催催，否则不建议你这么做。&lt;/p&gt;
&lt;h2 id="参考项目"&gt;参考项目
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://github.com/flyhigher139/mayblog" target="_blank" rel="noopener"
&gt;https://github.com/flyhigher139/mayblog&lt;/a&gt;&lt;/p&gt;</description></item><item><title>使用Docker安装Spark</title><link>https://svtter.cn/p/%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85spark/</link><pubDate>Tue, 26 Dec 2017 01:00:00 +0800</pubDate><guid>https://svtter.cn/p/%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85spark/</guid><description>&lt;p&gt;在国内加载Dockerhub上的镜像速度会比较慢，对此我们可以通过设置mirror镜像的方式来加速images的下载。&lt;/p&gt;
&lt;p&gt;此外，如果是ipv6的网络，在一些mirror可以直接走ipv6通路，速度非常客观。这里以USTC的mirror为例。&lt;/p&gt;
&lt;p&gt;我这里的环境是Ubuntu 14.04，对于不同的Linux环境，修改的方式都差不多；修改文件&lt;code&gt;/etc/docker/daemon.json&lt;/code&gt;，如果没有这个文件，创建一个，注意，此处可能需要&lt;code&gt;root&lt;/code&gt;权限。修改完成后，运行命令&lt;code&gt;sudo service docker restart&lt;/code&gt;重启docker服务。&lt;/p&gt;
&lt;div class="codehilite"&gt;
&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nt"&gt;"registry-mirrors"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"https://docker.mirrors.ustc.edu.cn"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;配置好以后，选择&lt;code&gt;2.1.0&lt;/code&gt;版本的spark进行docker下载。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker pull p7hb/docker-spark:2.1.0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者直接运行&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker run -it -p 4040:4040 -p 8080:8080 -p 8081:8081 -h spark --name=spark p7hb/docker-spark:2.1.0&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="参考"&gt;参考
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a class="link" href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker" target="_blank" rel="noopener"
&gt;https://lug.ustc.edu.cn/wiki/mirrors/help/docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://github.com/P7h/docker-spark" target="_blank" rel="noopener"
&gt;https://github.com/P7h/docker-spark&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>使用Docker的一些Tips</title><link>https://svtter.cn/p/%E4%BD%BF%E7%94%A8docker%E7%9A%84%E4%B8%80%E4%BA%9Btips/</link><pubDate>Fri, 07 Jul 2017 01:00:00 +0800</pubDate><guid>https://svtter.cn/p/%E4%BD%BF%E7%94%A8docker%E7%9A%84%E4%B8%80%E4%BA%9Btips/</guid><description>&lt;p&gt;Docker是一种强大的DevOps工具，使用其无论是作为开发环境还是生产环境，但是非常&lt;/p&gt;
&lt;p&gt;好的选择；在这篇文章中，讲讲Docker的几个开发Tips。&lt;/p&gt;
&lt;h2 id="几条命令安装docker"&gt;几条命令安装Docker
&lt;/h2&gt;&lt;div class="codehilite"&gt;
&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ curl -fsSL get.docker.com -o get-docker.sh
$ sudo sh get-docker.sh
&lt;/pre&gt;
&lt;/div&gt;
&lt;h2 id="使用多个基础镜像"&gt;使用多个基础镜像
&lt;/h2&gt;&lt;p&gt;作为Python开发者，经常需要使用pip来构建安装包，等待pip安全的过程可谓是又臭又长，&lt;/p&gt;
&lt;p&gt;而且一个不小心，如果在没有使用pip.conf的情况下，安装失败，docker又要重新跑一次，&lt;/p&gt;
&lt;p&gt;十分的麻烦。下面给出的解决方案不一定是最好的，但是应该是比较有效的。&lt;/p&gt;
&lt;p&gt;比如，我在构建某个Python项目的时候，会创建一个python-base的image，tag使用当前&lt;/p&gt;
&lt;p&gt;项目名称。&lt;/p&gt;
&lt;p&gt;这个python-base就是基础镜像之一：&lt;/p&gt;
&lt;div class="codehilite"&gt;
&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="s"&gt; dockerxman/docker-ubuntu:latest&lt;/span&gt;
&lt;span class="k"&gt;MAINTAINER&lt;/span&gt;&lt;span class="s"&gt; Svtter &amp;lt;svtter@qq.com&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; apt-get update&lt;span class="se"&gt;\&lt;/span&gt;
&lt;span class="o"&gt;&amp;&amp;&lt;/span&gt; apt-get install python3-pip supervisor -y
COPY ./requirements.txt /app/requirements.txt
COPY ./pip/pip.conf /root/.pip/pip.conf
&lt;span class="k"&gt;RUN&lt;/span&gt; pip3 install -r /app/requirements.txt
&lt;span class="k"&gt;RUN&lt;/span&gt; rm -rf /var/lib/apt/lists/*
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;介绍一下这个&lt;code&gt;Dockerfile&lt;/code&gt;；在第一行，我使用的是一aliyun源的ubuntu镜像，来加速&lt;/p&gt;
&lt;p&gt;apt的过程，然后，把pip相关的配置复制到image中，最后，使用pip安装需求文件，&lt;/p&gt;
&lt;p&gt;清理缓存，然后这个基础镜像就构建好了。&lt;/p&gt;
&lt;h2 id="创建自己的项目"&gt;创建自己的项目
&lt;/h2&gt;&lt;div class="codehilite"&gt;
&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="s"&gt; python-base:school&lt;/span&gt;
&lt;span class="k"&gt;MAINTAINER&lt;/span&gt;&lt;span class="s"&gt; Svtter &amp;lt;svtter@qq.com&amp;gt;&lt;/span&gt;
COPY ./fleetness /app
&lt;span class="k"&gt;WORKDIR&lt;/span&gt;&lt;span class="s"&gt; /app&lt;/span&gt;
COPY supervisord.conf /etc/supervisord.conf
&lt;span class="k"&gt;WORKDIR&lt;/span&gt;&lt;span class="s"&gt; /log&lt;/span&gt;
&lt;span class="k"&gt;CMD&lt;/span&gt;&lt;span class="s"&gt; supervisord -c /etc/supervisord.conf&lt;/span&gt;
STOPSIGNAL SIGINT
&lt;span class="k"&gt;EXPOSE&lt;/span&gt;&lt;span class="s"&gt; 5000&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;此处就是这直接利用已经构建好的&lt;code&gt;python-base:school&lt;/code&gt;的镜像，这样一来，每次我更新&lt;/p&gt;
&lt;p&gt;代码，或者supervisor的配置，只需要重新构建这个镜像就可以了。在这个镜像中，没有&lt;/p&gt;
&lt;p&gt;安装其他软件包的过程，因此节省了大量的时间。&lt;/p&gt;
&lt;p&gt;此外，如果只需要更新代码，而依赖相对不改变的时候，可以通过挂载代码到VOLUME中，&lt;/p&gt;
&lt;p&gt;每次更新代码，都通过&lt;code&gt;git pull&lt;/code&gt;，然后重启一下镜像，就可以重新部署了。&lt;/p&gt;
&lt;h2 id="docker-构建python镜像的一些技巧"&gt;Docker 构建Python镜像的一些技巧
&lt;/h2&gt;&lt;p&gt;使用pip快速 &lt;a class="link" href="http://blog.csdn.net/lambert310/article/details/52412059" target="_blank" rel="noopener"
&gt;http://blog.csdn.net/lambert310/article/details/52412059&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="一条命令搭建lamp"&gt;一条命令搭建LAMP
&lt;/h2&gt;&lt;p&gt;这条命令创建一个apache-php服务器，服务于&lt;code&gt;8087&lt;/code&gt;端口。&lt;/p&gt;
&lt;div class="codehilite"&gt;
&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run --rm -p &lt;span class="m"&gt;8087&lt;/span&gt;:80 -e &lt;span class="nv"&gt;ALLOW_OVERRIDE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt; -v &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;项目的绝对路径&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;:/var/www/html tutum/apache-php
&lt;/pre&gt;
&lt;/div&gt;</description></item></channel></rss>