<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ACM/ICPC on Svtter&#39;s Blog</title>
    <link>https://svtter.cn/categories/acm/icpc/</link>
    <description>Recent content in ACM/ICPC on Svtter&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="https://svtter.cn/categories/acm/icpc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>第六届山东省ACM总结</title>
      <link>https://svtter.cn/2015/05/16/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%B1%B1%E4%B8%9C%E7%9C%81acm%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 16 May 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/05/16/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%B1%B1%E4%B8%9C%E7%9C%81acm%E6%80%BB%E7%BB%93/</guid>
      <description> 拖了好久才写这份总结，中间考试，聚会，等等都推迟了这事儿。写的过程中一度想要不写了，可能是觉得结果有些不尽人意吧。
 赛程 早上6点多起床，然后吃了个早饭，大概7点钟出发，路上前面的两位都在听歌，我因为耳机找不到，也没有下电影，思想神游了4个小时，也是挺佩服自己的 — 或者是刷微博？
到了以后大体上逛了下山科的校园，挺大，环境也不错，但是明显能够感觉出年轻，没有岁月的味道，心情一直是比较平静的。下午热身赛，没有特别出彩，已经不记得当时在个什么名次上 — 反正也不是很重要= =
然后就是正式比赛，拿了铜牌。
 不想空洞的描述这场比赛，还是随意一点，然后再简单整理一下吧。
 比赛之前的晚上发现自己博弈部分没有掌握好，图论部分也是没有完全看完重点，但是因为第五届的比赛的原因，觉得无妨，图论题目应该出了也做不出来（的确，没做出来，笑），博弈因为去年有一个（后来想到可能是记错了），所以也是没有很在意，觉得应该不至于不幸的一次就搞到我不擅长的地方吧！
结果正式比赛正好考到博弈和图论，博弈费了好些力才推理出来，图论一开始搞错了题目的意思，最后分析题目计算时间复杂度的时候就已经发现可能超时间，但是没有找出合理的办法 — 其实在当时看看，也的确应该是去试试，因为感觉可能比较简单，AC的人并不少。
当然赛后发现如果有那个知识，那么这道题目还是比较简单的，哈哈。
GH题目就是比较简单的质因子分解+哈希，但是糟糕的是当时虽然想到质因子分解，但是没有具体的细想，去探究，深度不够。 — 也是因为受了之前比赛的影响，很多时候因为我自己想得太深方向还不对结果浪费了时间。
总结 </description>
    </item>
    
    <item>
      <title>ACM – 浙江省赛F – 图论</title>
      <link>https://svtter.cn/2015/05/07/acm-%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bf-%E5%9B%BE%E8%AE%BA/</link>
      <pubDate>Thu, 07 May 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/05/07/acm-%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9Bf-%E5%9B%BE%E8%AE%BA/</guid>
      <description>  浙江省赛题目，分析后直接暴力即可，奈何场上脑子里全是floyd，WA无数次。
  做题一定要先分析时间复杂问题，采取暴力方法，然后再考虑复杂问题解决方法。
  此外今天开始使用赛用vimrc才发现出现不少问题，还好提前使用了。
  </description>
    </item>
    
    <item>
      <title>ACM – Uva10047 – 图论</title>
      <link>https://svtter.cn/2015/05/05/acm-uva10047-%E5%9B%BE%E8%AE%BA/</link>
      <pubDate>Tue, 05 May 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/05/05/acm-uva10047-%E5%9B%BE%E8%AE%BA/</guid>
      <description>隐式图搜索，多个状态然后减枝。。没看懂李大大所说可以承受是个啥意思。。
做起来实在太累了。。减枝的部分看了别人的代码，发现着实麻烦，不如用优先队列来的痛快=- =还有用优先队列做的= =
主要是$vis[x][y][p][c]$这组状态比较难搞，但是给了优先级（时间短的先出队），事情就好办了。</description>
    </item>
    
    <item>
      <title>ACM – Uva10054 – 欧拉回路</title>
      <link>https://svtter.cn/2015/05/05/acm-uva10054-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/</link>
      <pubDate>Tue, 05 May 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/05/05/acm-uva10054-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/</guid>
      <description>问能不能拼接一条项链，条件是首尾相同构成环。
这个题的坑在：
  虽然保证连通，但是不一定每个颜色都有，所以单纯的暴力euler(1)是很愚蠢的。
  题目本身是要求顺序输出的，也就是dfs不能回溯，如果回溯，为了保证准确性，需要交换uv的位置来保证。
  通过统计出度入度判断是否满足欧拉回路。
  </description>
    </item>
    
    <item>
      <title>灭火</title>
      <link>https://svtter.cn/2015/05/04/%E7%81%AD%E7%81%AB/</link>
      <pubDate>Mon, 04 May 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/05/04/%E7%81%AD%E7%81%AB/</guid>
      <description>火会蔓延，人被火追着跑，能否跑出边界的问题。
bfs火之后bfs人，或火和人放在一个队列里面bfs
坑是没有火的情况，如果从0更新火势图而不是inf开始，那么可能造成没火不能跑的情况。</description>
    </item>
    
    <item>
      <title>ACM – Uva10294 – 置换</title>
      <link>https://svtter.cn/2015/05/03/acm-uva10294-%E7%BD%AE%E6%8D%A2/</link>
      <pubDate>Sun, 03 May 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/05/03/acm-uva10294-%E7%BD%AE%E6%8D%A2/</guid>
      <description>项链和手镯。
项链的问题在于不可以翻转，因此少了一种置换，而手镯则可以反转。然后我们计算旋转的置换。
旋转的步长可以是0,i,2i…然后我们可以得出循环一共有n/gcd(i,n)个元素，因此，我们可以计算出一共有gcd(i,n)个循环。则不定点的个数为
$a = \Sigma t^{gcd(i,n)}$。
翻转。翻转奇数情况和偶数情况是不一样的，因为奇数情况会多一个不定点，这个不定点就是在轴上的点。剩余的不定点的个数就是$n/2$，总共不定点的个数就是$nt^{(n+1)/2}$。偶数的情况下，如果正好切在两个珠子上，那么循环长度为2的点有$n/2-1$个，长度为1的循环有2个，所以总共$n/2+1$个。如果没有切在珠子上，不定点的个数为$n/2$，和为$b = n/2*(t^{n/2+1} + t^{n/2})$。
然后我们可以计算出项链的个数$a/n$，手镯的个数$(a+b)/2n$
列出式子以后代码就方便了。记得求pow的时候可以顺手打表</description>
    </item>
    
    <item>
      <title>ACM – 置换</title>
      <link>https://svtter.cn/2015/05/03/acm-%E7%BD%AE%E6%8D%A2/</link>
      <pubDate>Sun, 03 May 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/05/03/acm-%E7%BD%AE%E6%8D%A2/</guid>
      <description>终于搞明白置换了，可喜可贺。建议不要看屈的离散数学，看白书即可，通俗易懂。
我在这里简单阐述一下，当然也是依据李大大的书。
置换 置换就是把n个元素全排列，置换可以定义乘法。
循环就是置换的移位。例如：
   1 2 3 4 5     3 5 1 4 2    即为(1 3)(2 5)(4)
其中，(1 3)通过这个置换发现形成一个循环，(2 5)通过这个置换形成一个循环，(4)本身构成一个循环。
不动点 对于一个置换f，若一个着色方案s经过置换后不变，则称s为f的不动点，将f的不动点记录为C(f)，则可证明等价类数目为所有C(f)的平均值，成为Burnside引理。
Polya定理 一般的，如果f分解成m(f)个循环的乘积，那么每个循环的所有格子的颜色必须相同。（因为这样才是一个不动点）。
假设涂k种颜色，则有
$$C(f) = k^{m(f)}$$
（乘法原理。循环内相同，循环间可以不同）。
代入Burnside引理之后得到Polya定理：等价类的个数等于所有置换f的$k^{m(f)}$的平均数。</description>
    </item>
    
    <item>
      <title>ACM – UVa10023 – 开平方</title>
      <link>https://svtter.cn/2015/05/02/acm-uva10023-%E5%BC%80%E5%B9%B3%E6%96%B9/</link>
      <pubDate>Sat, 02 May 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/05/02/acm-uva10023-%E5%BC%80%E5%B9%B3%E6%96%B9/</guid>
      <description>本题目计算开根号数字，给出Y求X。X = sqrt(Y)，主要问题在Y的超大数据。
时间限制是3s。我使用的大数模板中没有一个大数除大数的算法，因此直接借用Java来搞一搞。
利用公式$$(5/x+x)/2 = x$$递归逼近求解。这个公式比较好推，移项即可。
参考他人代码，不需要用set，直接判断是否和前一个相等即可= =。
再一个就是模拟手算。手算法有些麻烦。。注意第二个除数开始余数*20即可。</description>
    </item>
    
    <item>
      <title>ACM – Uva10105 – 组合数</title>
      <link>https://svtter.cn/2015/05/02/acm-uva10105-%E7%BB%84%E5%90%88%E6%95%B0/</link>
      <pubDate>Sat, 02 May 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/05/02/acm-uva10105-%E7%BB%84%E5%90%88%E6%95%B0/</guid>
      <description>基本上是组合数裸题。。
给出$(x_1+x_2+x_3….x_k)^n$，要求计算$x_1^{n_1}x_2^{n_2}…x_k^{n_k}$的系数。
思想就是从一个算式中取出$n_k$，即$C_n^{n_k}$，然后减去$n_k$，如果直接相乘则会重复。</description>
    </item>
    
    <item>
      <title>ACM – UVA10308 – 无根树转有根树</title>
      <link>https://svtter.cn/2015/05/02/acm-uva10308-%E6%97%A0%E6%A0%B9%E6%A0%91%E8%BD%AC%E6%9C%89%E6%A0%B9%E6%A0%91/</link>
      <pubDate>Sat, 02 May 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/05/02/acm-uva10308-%E6%97%A0%E6%A0%B9%E6%A0%91%E8%BD%AC%E6%9C%89%E6%A0%B9%E6%A0%91/</guid>
      <description>比较莫名奇妙的题目，明明是搜索题目居然放在了数学分类，完全找不到数学的影子。。
利用vector，遍历树，找出最大的子树路径，然后与次大的子树路径相加即为答案。
因为图表示这方面太渣，基本上抄袭了别人的代码= =</description>
    </item>
    
    <item>
      <title>ACM – Uva10375 – 组合数公式</title>
      <link>https://svtter.cn/2015/05/02/acm-uva10375-%E7%BB%84%E5%90%88%E6%95%B0%E5%85%AC%E5%BC%8F/</link>
      <pubDate>Sat, 02 May 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/05/02/acm-uva10375-%E7%BB%84%E5%90%88%E6%95%B0%E5%85%AC%E5%BC%8F/</guid>
      <description>有些匪夷所思的题目。。注释部分加上就WA，不加就AC。。
推公式，因为$$C(n,k) = C(n,k-1) * (n-k+1)/k$$
所以$$ans = \frac{C(n, k)}{C(r, s)}\qquad$$改成递推即可。</description>
    </item>
    
    <item>
      <title>ACM – UVA11029 – 快速幂，快速前幂</title>
      <link>https://svtter.cn/2015/05/02/acm-uva11029-%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%8C%E5%BF%AB%E9%80%9F%E5%89%8D%E5%B9%82/</link>
      <pubDate>Sat, 02 May 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/05/02/acm-uva11029-%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%8C%E5%BF%AB%E9%80%9F%E5%89%8D%E5%B9%82/</guid>
      <description>后面的三位快速幂即可，但是前面三位不好求。经过分析，每一位都有可能牵扯到前三位的值，因此无法具体的作出判断。
如果使用模方法省去后面的部分，必定会造成误差，随着省略的部分增多，误差积累势必会越来越大。（错了一组数据）
最佳的方法还是数学分析（参考了题解）：
分析n，$a = log_{10}^n$，则$n = a ^ {10}$。分解a = i + d，i为正数部分，d为小数部分。那么i影响的仅仅是位数，d影响的则是具体的数字。
这样得到的值是准确的。另外对浮点数取余</description>
    </item>
    
    <item>
      <title>ACM – UVA10820 – 欧拉函数</title>
      <link>https://svtter.cn/2015/05/01/acm-uva10820-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 01 May 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/05/01/acm-uva10820-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</guid>
      <description>给出一个Answer(x,y)函数，x,y属于[1,N]，$Answer(k_x, k_y)$可以由Answer(x,y)得出，目的是求需要计算多少Answer(x,y)。
就是求1,N范围的欧拉函数的加和。欧拉函数的定义是与N互质的数的个数，所以需要如此计算。一开始没有发现就是求欧拉惭愧惭愧。</description>
    </item>
    
    <item>
      <title>ACM – UVA571 – 模方程</title>
      <link>https://svtter.cn/2015/05/01/acm-uva571-%E6%A8%A1%E6%96%B9%E7%A8%8B/</link>
      <pubDate>Fri, 01 May 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/05/01/acm-uva571-%E6%A8%A1%E6%96%B9%E7%A8%8B/</guid>
      <description>一开始在扩展gcd上想了许久没有办法将得出的数字直接转换成为相应的输出，后来发现就是模方程。
因为不求最佳解，所以直接使用ca*x = n (mod cb)即可。这个方程的解可以覆盖全部的n，因为该方程如果有解，则n是gcd(ca, cb)的倍数。因为ca, cb互质 gcd (ca, cb) = 1，所以明显通过单纯的加满B，向A中倒，然后清空A就可以遍历所有n的解（尽管可能不是最佳解）。
不能是cb*x = n (mod ca)，因为n可能大于ca.
如果求最佳解，显然是bfs。当然这到题目也可以dfs来做，不过明显要复杂很多。</description>
    </item>
    
    <item>
      <title>ACM – Uva10717 – lcm&#43;dfs</title>
      <link>https://svtter.cn/2015/04/29/acm-uva10717-lcm&#43;dfs/</link>
      <pubDate>Wed, 29 Apr 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/04/29/acm-uva10717-lcm&#43;dfs/</guid>
      <description>今天不适合刷题。。。
题意：一个桌子4条腿，每条腿由一种硬币构成，四条腿必须一样长，请问如何最接近给出的标准桌子高度，输出两个最接近的值。
更新两个值的时候错误的判断如果lcm大于h就不再更新了，却没有想到高于h的部分依然可以更新，只是不能更新小于h的部分了。</description>
    </item>
    
    <item>
      <title>ACM – UVa10791 – divide prime</title>
      <link>https://svtter.cn/2015/04/29/acm-uva10791-divideprime/</link>
      <pubDate>Wed, 29 Apr 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/04/29/acm-uva10791-divideprime/</guid>
      <description>谢天谢地终于过了。
就是求分解质因数后的和，如果是质数那么返回1+n本身。
  一开始直接暴力求两个质因数的情况，铁定不对啊。。 第二次发现策略有问题，转为使用枚举质因数，然后发现仅仅是质因数LCM有问题啊。。 第三次没有考虑质数 第四次没有考虑Case 第五次不记得了。 第七次AC，哭了真是。。一定要先分析好题目啊。   </description>
    </item>
    
    <item>
      <title>ACM – Uva106 – 勾股定理</title>
      <link>https://svtter.cn/2015/04/28/acm-uva106-%E5%8B%BE%E8%82%A1%E5%AE%9A%E7%90%86/</link>
      <pubDate>Tue, 28 Apr 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/04/28/acm-uva106-%E5%8B%BE%E8%82%A1%E5%AE%9A%E7%90%86/</guid>
      <description>從維基百科的勾股數條目參考來的通解：
給一個任意數對(X,Y)，用以下公式代替
 $A = X^2 – Y^2$
  $B = 2XY$
  $C = X^2 + Y^2$
  得出的A,B,C就是一組勾股數。
 若 (X,Y) 恰好互質而且一奇一偶，那麼會得到一組(A,B,C)互質的勾股數。
知道通解後，雙層迴圈跑 (X,Y) 就能找出所有互質勾股數。
按照台湾同胞的题解。 — 勾股数公式也是很神奇的啊。。。
此外还学习了bitset，因为是按位存储，所以比一般的bool来的更加迅速，也更加节省时间。</description>
    </item>
    
    <item>
      <title>ACM – Uva10673 – 扩展gcd</title>
      <link>https://svtter.cn/2015/04/28/acm-uva10673-%E6%89%A9%E5%B1%95gcd/</link>
      <pubDate>Tue, 28 Apr 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/04/28/acm-uva10673-%E6%89%A9%E5%B1%95gcd/</guid>
      <description>水题一发。。直接使用floor和ceil函数，然后暴力即可。。。
如果使用快速的方法，就是扩展gcd。其中d的初始值没有关系，最后返回的是gcd(a,b).
暴力算法 扩展gcd算法 速度更快，0.012</description>
    </item>
    
    <item>
      <title>ACM – UVA11121 – 进制</title>
      <link>https://svtter.cn/2015/04/28/acm-uva11121-%E8%BF%9B%E5%88%B6/</link>
      <pubDate>Tue, 28 Apr 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/04/28/acm-uva11121-%E8%BF%9B%E5%88%B6/</guid>
      <description>题意是由10进制转换成-2进制，但是明显我分析错了，所以写了调了接近一下午的bug。。。
有时间再写正常的题解。
题解：
 如果当前数位和输入n符号相同，那么不做处理，如果不同且为1，那么下一位（即左边一位）做+1处理 — 因为下一位是上一位的2倍，就相当于做一个变号处理。</description>
    </item>
    
    <item>
      <title>ACM – 莫比乌斯反演</title>
      <link>https://svtter.cn/2015/04/27/acm-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</link>
      <pubDate>Mon, 27 Apr 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/04/27/acm-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</guid>
      <description>昨天卡了这道题目，今天特意来看看莫比乌斯反演。
其中，$∑_{d|n}$含义为整除.
 ACdreamer大大的讲解
 看了这篇文章即可= =
wikipedia的公式: 以上就是具体的公式，此外，还有线性筛法:
这段代码也是摘自AC大大。我们得到这个东西有什么用？
简单来说，就是简化计算数论函数和的计算的过程，进行加速。
在HDU5212中，给出的题解是：
 这道题需要一些莫比乌斯反演、线性筛的知识
  定义$f(x)=x∗(x−1)$
  题目所求即为$\Sigma(f(gcd(ai,aj)|i!=j,1≤i,j≤n)$
  先用线性筛求出miu在[1,10000]的函数值
  利用莫比乌斯反演公式我们可以$O(vlogv)$暴力求解出函数g（就是$f(n)/miu$）在[1,10000]的函数值，其中g满足：
  $\Sigma(g(d)|x)$
  这样所求答案即为：
  $\Sigma(g(d)∗cnt(d)∗cnt(d)|1≤d≤10000)$，其中cnt函数满足：
  cnt(x)=在a1,a2,..,an中是x的倍数的个数
  而cnt的取值也可以$O(vlogv)$暴力计算出
  所以总的时间复杂度就是$O(vlogv)$的
 就是这样。</description>
    </item>
    
    <item>
      <title>Bestcoder 2 题目</title>
      <link>https://svtter.cn/2015/04/27/bestcoder2%E9%A2%98%E7%9B%AE/</link>
      <pubDate>Mon, 27 Apr 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/04/27/bestcoder2%E9%A2%98%E7%9B%AE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ACM – UVa10006 – 快速幂</title>
      <link>https://svtter.cn/2015/04/25/acm-uva10006-%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
      <pubDate>Sat, 25 Apr 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/04/25/acm-uva10006-%E5%BF%AB%E9%80%9F%E5%B9%82/</guid>
      <description>水题一发。无奈自己没有好好审清题意，另外快速幂居然写错了- =
快速幂在过程中修改a的值，但是我却计算成了在偶数时相乘，调试半天。看来还是咩有好好理解啊。</description>
    </item>
    
    <item>
      <title>ACM – UVa138 – 数学基础</title>
      <link>https://svtter.cn/2015/04/24/acm-uva138-%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 24 Apr 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/04/24/acm-uva138-%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</guid>
      <description>这道题目其实就是推个公式，主要还是考验编程技巧。。
首先double的精度范围是15-16位，浮点数运算还是最快的，依据最后一个答案（总共10组），平方为16位刚好够用。
如果想要最精确的结果，当然还是使用long double或者long long来来保证精度问题。不过计算速度就会有所损失，采取二分的方法加速比较好。
 利用double的代码：
利用long long的代码:
 不过有一点就是无论怎么个快法，不使用打表肯定是会超时的，所以算出来直接上交即可。= =。这在大赛中应该也是允许的吧。</description>
    </item>
    
    <item>
      <title>山东省第五届省赛  Circle</title>
      <link>https://svtter.cn/2015/04/21/%E5%B1%B1%E4%B8%9C%E7%9C%81%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%9C%81%E8%B5%9Bcircle/</link>
      <pubDate>Tue, 21 Apr 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/04/21/%E5%B1%B1%E4%B8%9C%E7%9C%81%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%9C%81%E8%B5%9Bcircle/</guid>
      <description>首先一点什么是高斯消元？
高斯消元其实就是一种求行列式的值的方法。
例如
|a[0][0]_x1 + a[0][1]_x2+ … a[0][n-1]_xn = a[0][n]|
|a[1][0]_x1 + a[1][1]_x2+ … a[1][n-1]_xn = a[1][n]|
|a[2][0]_x1 + a[2][1]_x2+ … a[2][n-1]_xn = a[2][n]|
|a[3][0]_x1 + a[3][1]_x2+ … a[3][n-1]_xn = a[3][n]|
…
|a[n-1][0]_x1 + a[n-1][1]_x2+ … a[n-1][n-1]*xn = a[n-1][n]|
已知a[x][y]，求x1, x2 .. xn的值。这个时候就可以使用高斯消元。
本题目就是高斯消元求解的一道题目。
依据题意，可以列出方程：
$$E[x] = 0.5_(E[x-1]+1) + 0.5_(E[x+1]+1)$$
其中E代表期望，利用高斯消元我们可以得到x1-xn的值，输出我们需要的E[x]即可。
高斯消元其实就是我们所说的消元，但是针对于大型的矩阵。
倒是很简单的题目。</description>
    </item>
    
    <item>
      <title>山东省第五届省赛 Hearthstone II</title>
      <link>https://svtter.cn/2015/04/21/%E5%B1%B1%E4%B8%9C%E7%9C%81%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%9C%81%E8%B5%9Bhearthstoneii/</link>
      <pubDate>Tue, 21 Apr 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/04/21/%E5%B1%B1%E4%B8%9C%E7%9C%81%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%9C%81%E8%B5%9Bhearthstoneii/</guid>
      <description>斯特林数stirling  第一类 stirling数 s(n, k)  n个人分成k组，组内再按特定顺序围圈
也就是分成了k组，组内就像是项链颜色一样，
 ( {A, B}, {C, D} ) ( {B, A}, {C, D} )  属于一组
 ({A}, {B, C, D}) ({A}, {B, D, C})  不属于一组
给定 $s(n,0)=0,s(1,1)=1$，有递归关系$s(n,k)=s(n-1,k-1) + (n-1) s(n-1,k)$
 第二类 stirling数  S(n, k) 是把p元素集合划分到k个不可区分的盒子里且没有空盒的划分个数。
公式:
$$ S(n, n) = 1 (n &amp;gt;= 0) $$
$$ S(n, 0) = 0 (n &amp;gt;= 1) $$
$$ S(n,k)=k*S(n-1,k)+S(n-1,k-1),\text (1&amp;lt;=k&amp;lt;=n-1) $$</description>
    </item>
    
    <item>
      <title>山东省第五届ACM省赛 Weighted Median</title>
      <link>https://svtter.cn/2015/04/19/%E5%B1%B1%E4%B8%9C%E7%9C%81%E7%AC%AC%E4%BA%94%E5%B1%8Aacm%E7%9C%81%E8%B5%9Bweightedmedian/</link>
      <pubDate>Sun, 19 Apr 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/04/19/%E5%B1%B1%E4%B8%9C%E7%9C%81%E7%AC%AC%E4%BA%94%E5%B1%8Aacm%E7%9C%81%E8%B5%9Bweightedmedian/</guid>
      <description></description>
    </item>
    
    <item>
      <title>bestcoder#2-1</title>
      <link>https://svtter.cn/2015/04/18/bestcoder#2-1/</link>
      <pubDate>Sat, 18 Apr 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/04/18/bestcoder#2-1/</guid>
      <description>一开始直接使用结构体搞结果wrong了，随后查看了某牛的代码发现应该直接在区间上累加 — 得出结论不要直接使用复杂的结构体，转变成简单的数据形式未尝不是一个好方法
原题:
http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=526&amp;amp;pid=1001</description>
    </item>
    
    <item>
      <title>蓝桥杯入门训练题目</title>
      <link>https://svtter.cn/2015/04/10/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%85%A5%E9%97%A8%E8%AE%AD%E7%BB%83%E9%A2%98%E7%9B%AE/</link>
      <pubDate>Fri, 10 Apr 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/04/10/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%85%A5%E9%97%A8%E8%AE%AD%E7%BB%83%E9%A2%98%E7%9B%AE/</guid>
      <description>蓝桥的系统需要I64d这种输入格式。无力吐槽。
Fibonacci数列 圆的面积 序列求和 A+B </description>
    </item>
    
    <item>
      <title>蓝桥杯基础练习</title>
      <link>https://svtter.cn/2015/04/10/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/</link>
      <pubDate>Fri, 10 Apr 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/04/10/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/</guid>
      <description>数列排序 十六进制转八进制 转换的时候，先转换成二进制，再转换成十六进制。
这道题目还是比较有意思的，使用string只需要78ms，使用char*则超时。可能strcat每次都需要从头遍历数组，但是string则不需要。
当然，如果是数字没有这么大，完全可以这样处理
是不是很精髓= =
十六进制转十进制 十进制转十六进制 由此也可以想到，如果是二进制的相关转换（数值范围允许的情况），我们可以写一个简单二进制转十六进制，然后利用sscanf来做进一步转换。
当然，正规的做法还是除二取余，逆序排列。
特殊回文数 回文数 特殊的数字
 只要读题不出问题就没有问题了。。。不刷了</description>
    </item>
    
    <item>
      <title>ACM – 三道统计题目</title>
      <link>https://svtter.cn/2015/04/08/acm-%E4%B8%89%E9%81%93%E7%BB%9F%E8%AE%A1%E9%A2%98%E7%9B%AE/</link>
      <pubDate>Wed, 08 Apr 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/04/08/acm-%E4%B8%89%E9%81%93%E7%BB%9F%E8%AE%A1%E9%A2%98%E7%9B%AE/</guid>
      <description>基本上就是按照大白学习的，基本上都是计数方法的运用。
这是的大体的对组合数学的学习导图。
指导 </description>
    </item>
    
    <item>
      <title>ACM – 快速生成测试数据</title>
      <link>https://svtter.cn/2015/04/08/acm-%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Wed, 08 Apr 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/04/08/acm-%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/</guid>
      <description>比赛的时候出现了100 * 100组数据的情况，但是当时使用freopen忘记了具体的步骤，特意重新写一下，也是属于基础的内容。
生成一百行数据，每行100个数据，每个数据为100。
运行过后生成的数据（本来应该输出在屏幕上，此时不会输出到屏幕，而是输出到文件）会保存到output文件中。如果需要使用直接更改output的文件名，再使用一次freopen(&#39;r&#39;)即可。</description>
    </item>
    
    <item>
      <title>大白刷题录</title>
      <link>https://svtter.cn/2015/03/12/%E5%A4%A7%E7%99%BD%E5%88%B7%E9%A2%98%E5%BD%95/</link>
      <pubDate>Thu, 12 Mar 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/03/12/%E5%A4%A7%E7%99%BD%E5%88%B7%E9%A2%98%E5%BD%95/</guid>
      <description>UVa 11729 UVa 11292 勇士斗恶龙 排序，贪心
UVa 11300 这个题目很有价值。
一方面通过数学推导得出结论。
编号为i的人初始有$A_i$枚金币。对于1号，给了4号$x_1$枚金币，自己还有$A_1-x_1$枚。然后从2号拿走$x_2$枚金币，现在有$A_1-x_1+x_2$枚金币，另外，设平均金币值为$A_1-x_1+x_2=M$。
由此可类推得到
$A_n-x_n+x_1 \Rightarrow x_n=M-A_n+x_1=x_n-C_n$
我们可以得到类推公式
$$C_i = C_{i-1} + A_i – M $$
证明:
$$x_2 = x_1 – C_1$$
$$x_3 = M-A_2+x_2 =2M-A_1-A_2+x_1=x_1-C_2$$\
以此类推。
可以求得，需要求的结果为:
$$|x_1|+|x_1-C_1|+|x_1-C_2|….|x_1-C_n-1|$$
即求这个式子值最小，即求$C_1, C_2, …C_n$的中位数。
LA 3708 这个题目也是比较有水平
使用了按比例缩小的技巧。其中，按逆时针编号，固定一个点作为原点，建立新坐标。原来的位置呈现在新坐标的位置为$pos = i/n*(n+m)$，如此，求移动距离则是$fabs(pos – floor(pos+0.5))/(n+m)$
UVa 10881 蓝桥杯去年山东省的初赛题目，的确有点意思= =
转换方向可以不必在意，因为最终看到的结果已经不知道最初的蚂蚁是哪一只了，所以不用纠结方向的问题。主要要考虑的是最终的位置，以及最初蚂蚁位置的存储，before，after的对应关系。</description>
    </item>
    
    <item>
      <title>ACM-白皮书3</title>
      <link>https://svtter.cn/2014/12/10/acm-%E7%99%BD%E7%9A%AE%E4%B9%A63/</link>
      <pubDate>Wed, 10 Dec 2014 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2014/12/10/acm-%E7%99%BD%E7%9A%AE%E4%B9%A63/</guid>
      <description> 本文出自svtter.com
 整数进制输出 把整数按照十进制，八进制和十六进制输出.
$2^32-n$补码表示法.
字符处理 使用Ctrl+D时, getchar()读到的是-1
假设一个年份为1993/12/12, 那么如何简单获取年月日？
使用sscanf函数.
可以使用fgets(s, MAXN, stdin)来获取简单的输入. 一次读入一行，包括空格，遇到\n结束读入
简单习题  分数统计  </description>
    </item>
    
    <item>
      <title>ACM-白皮书-练习</title>
      <link>https://svtter.cn/2014/12/04/acm-%E7%99%BD%E7%9A%AE%E4%B9%A6-%E7%BB%83%E4%B9%A0/</link>
      <pubDate>Thu, 04 Dec 2014 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2014/12/04/acm-%E7%99%BD%E7%9A%AE%E4%B9%A6-%E7%BB%83%E4%B9%A0/</guid>
      <description>本文出自svtter.com  基础第二弹 虽然是很水的题目，但是还是收获了不少。
动态小数位数 整数位数 电灯 蛇型填数 调和级数 题目都很水（不能再水了），但是也算是有所收获。学习了一部分C。</description>
    </item>
    
    <item>
      <title>ACM-白皮书</title>
      <link>https://svtter.cn/2014/12/01/acm-%E7%99%BD%E7%9A%AE%E4%B9%A6/</link>
      <pubDate>Mon, 01 Dec 2014 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2014/12/01/acm-%E7%99%BD%E7%9A%AE%E4%B9%A6/</guid>
      <description>本文出自svtter.com  Pi的获取 觉得自己的一些ACMer的基本素养不够，重新翻看。
pi = 4.0 * atan(1.0)
math.h中的M_PI并不是ANSI C标准。验证可以使用gcc -ansi
scanf输入格式实验 之前阅读了scanf函数的相关部分（百科），但是依然没有很好的掌握。
现在依然没有= =。
有时间需要重新学习一下。
判断整数和浮点数大小 floor(m + 0.5) == m
通过+0.5来判断m的整数值。
floor/ceil是数学库里提供的函数，默认gcc不会自动链接math库, 方法是(-l + 库)
gcc -Wall myround.c -lm -o myround
使用clock()计时  包含头文件time.h printf(&amp;quot;Time used = %.2lf\n&amp;quot;, (double)clock() / CLOCKS_PER_SEC);  会从程序开始的时候计时（不管输入输出），所以最佳方法是echo 数据 | ./a.out
多次使用clock()来计时的吧。。。
重定向和fopen读取文件输入测试数据 添加编译选项：-DLOCAL， 使得中间部分生效.
fopen在linux不支持，所以不写了。</description>
    </item>
    
    <item>
      <title>ACM-zoj3789-排列利用</title>
      <link>https://svtter.cn/2014/11/27/acm-zoj3789-%E6%8E%92%E5%88%97%E5%88%A9%E7%94%A8/</link>
      <pubDate>Thu, 27 Nov 2014 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2014/11/27/acm-zoj3789-%E6%8E%92%E5%88%97%E5%88%A9%E7%94%A8/</guid>
      <description>本文出自&amp;lt;svtter.com&amp;gt;  利用排列找规律。
首先利用next_permutation函数进行求排列
代码如上。
可以观察出规律，然后即可AC。
详细代码下次再写= =
AC代码 规律在代码中，很明确。</description>
    </item>
    
    <item>
      <title>筛素数更正</title>
      <link>https://svtter.cn/2014/11/26/%E7%AD%9B%E7%B4%A0%E6%95%B0%E6%9B%B4%E6%AD%A3/</link>
      <pubDate>Wed, 26 Nov 2014 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2014/11/26/%E7%AD%9B%E7%B4%A0%E6%95%B0%E6%9B%B4%E6%AD%A3/</guid>
      <description>本文出自&amp;lt;svtter.com&amp;gt;  写在之前 maker关于线性筛素数的论文。
做到欧拉线性筛法再做补充。(当时还写了个这？)
关于线性筛素数   之前一直没有正视线性筛素数的问题。今天特意来写一个伪证明。如果当前的i不是素数，那么必然被之前的某个素数筛掉了。i × prime[j]。
一个合数必然可以写成几个素数的乘积，再或者就是p×i这种形式。如果能被i×p1筛掉之后则不需要i×p2继续筛了，i×p2可以写成p1×(i×p2)
   例如12可以被6×2筛掉，之前4×3这种筛除就可以去掉。
  这种方法会不会存在没有筛掉的合数？   不可能：i会一直到n，也就是整个范围都会包含在内。
 代码： 之前的错误在于筛素数的时候没有筛去2的倍数，所以出现后面的值错误。</description>
    </item>
    
    <item>
      <title>ACM – hdu5104-water</title>
      <link>https://svtter.cn/2014/11/16/acm-hdu5104-water/</link>
      <pubDate>Sun, 16 Nov 2014 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2014/11/16/acm-hdu5104-water/</guid>
      <description>&lt;p&gt;这个题目的总结就是不作不会死- -好端端的暴力我非要用个bfs。&lt;/p&gt;
&lt;p&gt;看见自己wrong了还以为是哈希的问题- =&lt;/p&gt;
&lt;h1 id=&#34;题意&#34;&gt;题意&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;p1+p2+p3 = n，$p1 &amp;lt;= p2 &amp;lt;= p3$&lt;/li&gt;
&lt;li&gt;输出符合条件的组数&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;输入输出&#34;&gt;输入输出&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;给100组n，输出组数&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;分析&#34;&gt;分析&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;只有3个数，暴力解就可以，注意循环终止条件。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>使用gdb调试</title>
      <link>https://svtter.cn/2014/11/16/%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95/</link>
      <pubDate>Sun, 16 Nov 2014 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2014/11/16/%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95/</guid>
      <description>最近都是用gcc+vim写代码，昨天突然写个代码算法出个逻辑bug，因为用了大量递归调用，DEB半天出不来也是醉了，于是
学习一下gdb——之前也是勉强使用过，但是明显感觉不爽阿。。所以这次好好学习，记录一下。
目前我能用到的几个命令：
选择调试文件  &amp;lt;shell&amp;gt;: gdb &amp;lt;file&amp;gt; 或者进入gdb以后，使用  断点 显示断点  (gdb): info break  添加静态断点  (gdb): b[reak] + 行数/函数名 (可以用tab补全)  添加条件断点 条件为真，则在断点处停止
– (gdb): b addr if condition
删除断点 删除编号为1的断点, 如果不加参数，会删除所有断点
– (gdb): delete breakpoint 1
启用/禁用断点  (gdb): disable breakpoint 1 (gdb): enable breakpoint 1  运行 开始运行  (gdb):r  继续  (gdb):c  单步调试 不进入单步执行
– (gdb):n
进入的单步
– (gdb):s[tep
显示变量 以变量为var为例</description>
    </item>
    
    <item>
      <title>ACM – hdu5086-water</title>
      <link>https://svtter.cn/2014/11/08/acm-hdu5086-water/</link>
      <pubDate>Sat, 08 Nov 2014 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2014/11/08/acm-hdu5086-water/</guid>
      <description>&lt;h2 id=&#34;题意&#34;&gt;题意&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;找出子序列和，因为数字过大，mod 1 000 000 007&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>线性时间选择</title>
      <link>https://svtter.cn/2014/11/08/%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9/</link>
      <pubDate>Sat, 08 Nov 2014 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2014/11/08/%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9/</guid>
      <description>定义 在给定线性序集中n个元素和一个整数k，要求找出n个元素中第k小的数。
方法一 线性时间选择，可以使用堆排序，这样就可以在$O(n+klog_n)=O(n)_的时间内找到的k小的元素。
方法二 使用快速排序中的分块算法，对所需要选择的数组分块，分完以后再在剩余的部分中，寻找(k – 减去分块的大小)
代码如下:
但是此方法在最差的情况下需要$n^2$的时间，比如在寻找最小元素时，总是在最大的元素划分。
尽管如此，平均效率还是不错的。
方法三 我还是比较喜欢直接看代码= =</description>
    </item>
    
  </channel>
</rss>
