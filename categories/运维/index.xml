<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>运维 on Svtter&#39;s Blog</title>
    <link>https://svtter.github.io/categories/%E8%BF%90%E7%BB%B4/</link>
    <description>Recent content in 运维 on Svtter&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 27 Jan 2018 01:00:00 +0800</lastBuildDate><atom:link href="https://svtter.github.io/categories/%E8%BF%90%E7%BB%B4/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用Fabric进行部署</title>
      <link>https://svtter.github.io/2018/01/27/%E4%BD%BF%E7%94%A8fabric%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Sat, 27 Jan 2018 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.github.io/2018/01/27/%E4%BD%BF%E7%94%A8fabric%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2/</guid>
      <description> Fabric是一个可以在远程机器上运行命令的库
Fabric官方目前只支持Python2版本，但是有勤劳的人开发出了适配Python3的版本。具体可以查看这个fork。
Fabric的使用 我在使用Fabric的时候主要是用于部署我的网站。使用时候，首先需要引入所有的API：
这样就可以导入Fabric的API进行远程控制啦。
具体问题 git需要输入密码 ssh通过秘钥链接 使用root 一个简单的部署例子 这个部署例子结合了更新代码，进入指定目录，运行命令等。
写好文件以后，保存为fabfile.py，运行fab deploy即可部署。deploy对应着deploy()函数。
NOTE：不在远程服务器上使用ssh的git仓库，是因为担心服务器被hack连累我的git repo。
参考资料 廖雪峰 15days python3-fabric </description>
    </item>
    
    <item>
      <title>记又一次搞崩服务器</title>
      <link>https://svtter.github.io/2018/01/11/%E8%AE%B0%E5%8F%88%E4%B8%80%E6%AC%A1%E6%90%9E%E5%B4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Thu, 11 Jan 2018 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.github.io/2018/01/11/%E8%AE%B0%E5%8F%88%E4%B8%80%E6%AC%A1%E6%90%9E%E5%B4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>记又一次搞崩服务器。使用“又”，是因为我搞崩不是一次两次了。我希望这是最后一次。
背景 使用Android连接服务器的时候，发现要比自己的mac速度快很多，于是十分好奇，打算研究一下是什么因素导致的。
流程 检查了app以后，判断应该是开启了fast TCP导致的，于是考虑在mac上也开启对应的fast TCP，但是效果并不是十分显著；于是再次排查，发现服务器端并没有开启fast TCP。
这就很奇怪了，为什么速度这么快呢？是因为对“同源”的加密方法有优化吗？
于是，自然而然的考虑是不是可以通过开启这个TCP加速来加速服务器。这就开启了噩梦的开端。因为需要3.7以上的Linux Kernel才支持这个特性，所以需要先升级内核。我的内核难道不应该是最新的吗？带着这个以为输入了uname sr，显示内核版本2.6*。惊奇，我的VPS内核这么旧吗？于是自然而然的想到要升级一下内核，并且理所应当的把升级内核的脚本apt-get install linux-kernel-lts-wily运行了一下。于是噩梦开始了。
OpenVZ本身是不支持升级内核的，所有的VM都使用同一个内核版本，因此这个命令导致了很神奇的BUG，安装内核装不上，卸载内核卸载不了。
这个时候我面临两个选择，一个是重新安装系统，一个是解决当前的这个问题。
经过简单地判断，我认为如果解决当前问题，可能花费我更多的时间，直接重新安装系统就可以了。重新配置一些相关措施也并不难。
失算的事情是，尽管我依稀记得一部分关于配置的内容，但是要完全复现我所配置的相关应用已经很难了，因为我没有做记录。于是来回又踩了许多坑，之前有些坑我有很明确的踩进去的记忆。
这就非常痛苦了，每次操作都在嘲讽自己的愚蠢与过度自信。最后，我只进行了简单的配置，只找回了部分的优化——记忆里我所做的优化就只有这些了，但是速度似乎下降了，这就是最终的结果。
这也让我想起《人月神话》里面描写的一句，具体我已经记不清了，意思大概是这样的：有些步骤你是必须要做的，只不过当前你没有做而已，以后是要补上的。我读到这个地方的时候，联想这个规律为“技术债”。
好了，以上就是我还“技术债”的全部过程了。
教训 研究问题虽然好，但是要注意花费的时间 在生产服务器上，不要做没有经过自查的操作。 不要被强迫症控制了，能用则用。 记录自己的行为日志，如果可以的话，写一个安装脚本 唉，真是一次不合格的运维行动。</description>
    </item>
    
    <item>
      <title>从grub rescue修复</title>
      <link>https://svtter.github.io/2014/11/10/%E4%BB%8Egrubrescue%E4%BF%AE%E5%A4%8D/</link>
      <pubDate>Mon, 10 Nov 2014 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.github.io/2014/11/10/%E4%BB%8Egrubrescue%E4%BF%AE%E5%A4%8D/</guid>
      <description>修复grub-rescue模式 今天删除了一个多余的分区，结果grub找不到原来的启动mod了，也是学习了。
grub-rescue模式中只能用ls, insmod, set root= , set prefix= ,这几个命令。
发现没搞定，重启还是不幸。
使用# grub2-install /dev/sda
然后就搞定= =</description>
    </item>
    
  </channel>
</rss>
