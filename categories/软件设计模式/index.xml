<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>软件设计模式 on Svtter&#39;s Blog</title>
    <link>https://svtter.cn/categories/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content in 软件设计模式 on Svtter&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 06 Aug 2021 10:41:16 +0800</lastBuildDate><atom:link href="https://svtter.cn/categories/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2021 08 06 How to TDD</title>
      <link>https://svtter.cn/posts/2021-08-06-how-to-tdd/</link>
      <pubDate>Fri, 06 Aug 2021 10:41:16 +0800</pubDate>
      
      <guid>https://svtter.cn/posts/2021-08-06-how-to-tdd/</guid>
      <description>测试驱动开发应该怎么做？ 测试驱动开发，是一种保证软件质量，提高研发效率的开发方法。
测试驱动开发的定义如下：
 测试驱动开发，英文全称Test-Driven Development，简称TDD，是一种不同于传统软件开发流程的新型的开发方法。它要求在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码，并加速开发过程。
 以上内容来自百度百科。
百度百科很好的说明了这个问题，我们本文不再赘述，只讲关键问题。
测试驱动开发的基本流程  快速新增一个不能通过的测试 运行测试（运行一个测试，或者所有的测试） 做尽可能少的改动，使测试通过 运行所有测试，并使其通过 重构代码，消除重复设计，优化结构  A: write a test B: make test pass C: refactor A -&amp;gt; B -&amp;gt; C -&amp;gt; A 功能测试应该怎么写？ 功能测试，应该尽可能只使用本层的函数和接口。 例如，功能测试应尽可能调用 django app 的 URL 接口，而不是直接调用 app 中的业务逻辑。 当然，如果准备数据较为复杂，可以利用一些工具函数，将基础数据加载到系统中。 这些工具函数，我们同样建议在功能测试层实现，而不是直接调用最底层的函数。
WEB 前端如何采用测试驱动开发  不测试样式。一般情况下，样式不是核心需求。 充分利用 HTML tag。例如：利用 class 定位元素 测试业务逻辑。针对历史 BUG 进行测试。 充分利用 Javascript 模块。写模块，而非脚本  </description>
    </item>
    
    <item>
      <title>软件设计模式 — 简单工厂模式</title>
      <link>https://svtter.cn/2015/07/14/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 14 Jul 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/07/14/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description></description>
    </item>
    
    <item>
      <title>关于软件设计与体系结构的学习</title>
      <link>https://svtter.cn/2015/05/21/%E5%85%B3%E4%BA%8E%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Thu, 21 May 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/05/21/%E5%85%B3%E4%BA%8E%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%A6%E4%B9%A0/</guid>
      <description>存在问题，比如进行UML学习的时候，发现简单的设计我也做不出，对UML图掌握程度比较差。
此外，设计模式并没有好好地敲代码，理解的也不够透彻。</description>
    </item>
    
    <item>
      <title>软件设计模式 — 行为型模式</title>
      <link>https://svtter.cn/2015/05/21/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 21 May 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/05/21/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>代码全部贴在github。因为UML图挂在processon上了，不过没有加连接。等写完全文就把链接加上。
首先是对象的行为模式：
1. 策略模式 针对一组算法，将每个算法封装到具有共同接口的独立类中，从而使得他们可以相互替换。
2. 状态模式 改变类中的状态。
策略模式和状态模式很像，不同在：状态模式解决内在状态的改变，策略模式解决内部算法的改变。感觉上没什么特别大的区别。- -。
3. 命令模式  类的行为模式：
1. 模板方法模式 </description>
    </item>
    
    <item>
      <title>软件设计模式 — 单例模式</title>
      <link>https://svtter.cn/2015/04/23/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 23 Apr 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/04/23/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>单例模式确保某个类只有一个实例，而且自行实例化，并向整个系统提供者个实例，提供一个访问它的全局访问点。
核心是：创造私有的构造函数
例如：只有一个实例的东西。
Singleton.java Client </description>
    </item>
    
    <item>
      <title>软件设计模式 — 适配器模式</title>
      <link>https://svtter.cn/2015/04/23/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 23 Apr 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/04/23/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>4该模式的目标是，通过一个代理(Adapter)，在原来的类(Adaptee)和客户(Client)之间进行协调，从而达到兼容的目的。
例如：我的项目中Davinci中使用的模式，将整体的游戏类作为Adapter，把用于通讯的Server类作为成员变量（也就是ObjectAdapter）。
示意代码 </description>
    </item>
    
    <item>
      <title>正方形是否是长方形的子类？</title>
      <link>https://svtter.cn/2015/04/09/%E6%AD%A3%E6%96%B9%E5%BD%A2%E6%98%AF%E5%90%A6%E6%98%AF%E9%95%BF%E6%96%B9%E5%BD%A2%E7%9A%84%E5%AD%90%E7%B1%BB%EF%BC%9F/</link>
      <pubDate>Thu, 09 Apr 2015 01:00:00 +0800</pubDate>
      
      <guid>https://svtter.cn/2015/04/09/%E6%AD%A3%E6%96%B9%E5%BD%A2%E6%98%AF%E5%90%A6%E6%98%AF%E9%95%BF%E6%96%B9%E5%BD%A2%E7%9A%84%E5%AD%90%E7%B1%BB%EF%BC%9F/</guid>
      <description>依据里氏代换原则，子类型必须能够替换掉它们的父类型，子类继承了父类，那么子类可以以父类的身份出现 — 在软件中，把父类都替换成它的子类，程序的行为没有变化。
所以从这个角度而言，正方形并非是长方形的子类。
举个例子，如果长方形中存在一个方法，目的是改变长宽的值，但是正方形只有一个边长，那么就可能出现问题。例如如下代码。
上面是椭圆形的代码。可以改写成矩形来解释这个问题，不过太麻烦我还是先做后面的题目了。</description>
    </item>
    
  </channel>
</rss>
