<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>学习 on Svtter's Blog</title><link>https://svtter.cn/categories/%E5%AD%A6%E4%B9%A0/</link><description>Recent content in 学习 on Svtter's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 31 Jan 2019 01:00:00 +0800</lastBuildDate><atom:link href="https://svtter.cn/categories/%E5%AD%A6%E4%B9%A0/index.xml" rel="self" type="application/rss+xml"/><item><title>编程语言与知识基础</title><link>https://svtter.cn/p/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%9F%A5%E8%AF%86%E5%9F%BA%E7%A1%80/</link><pubDate>Thu, 31 Jan 2019 01:00:00 +0800</pubDate><guid>https://svtter.cn/p/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%9F%A5%E8%AF%86%E5%9F%BA%E7%A1%80/</guid><description>&lt;p&gt;随着一部分编程经验的增长，我越来越觉得，程序设计语言是在知识基础上实现应用的工具。&lt;/p&gt;
&lt;p&gt;最初，在我进行应用编码的时候，往往让我 stuck 的东西就是基础知识。这种基础知识，比如 WSGI，session，cookie 这些东西；以及过于焦急的学习心态。总想做出点什么，但是却没有意识到做出一个东西需要积累和时间。&lt;/p&gt;
&lt;p&gt;语言的重要性在于，大量的使用语言会让你更了解你所使用的，与计算机交流的方式。这个很重要。语言使我们本身就站在巨人的肩膀上处理事情。因此，专注于一门语言在最初是十分重要的，因为我想很多人像我一样急于求成，并且很难按下心来慢慢学习知识基础。&lt;/p&gt;
&lt;p&gt;意识到的时间似乎有点晚，但是不算太迟。我也能够花一些时间在知识基础上，使得事情解决的更加清晰。&lt;/p&gt;
&lt;p&gt;还有就是硬件。想象中总是很美好的，但是实际上编程过程中，若是不考虑硬件，不考虑拓扑是不可取的。这是&lt;strong&gt;视角割裂&lt;/strong&gt;。最近一直都在读一些软件工程方面的书，但是读的越多，越不敢说。&lt;/p&gt;
&lt;p&gt;潜意识里，读的越多越发现自己懂得少，害怕自己说错。&lt;/p&gt;
&lt;p&gt;就这些，算是给 2018 年读者的一个交代。&lt;/p&gt;</description></item><item><title>将已经运行的进程切换到后台</title><link>https://svtter.cn/p/%E5%B0%86%E5%B7%B2%E7%BB%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E5%88%B0%E5%90%8E%E5%8F%B0/</link><pubDate>Thu, 17 Jan 2019 01:00:00 +0800</pubDate><guid>https://svtter.cn/p/%E5%B0%86%E5%B7%B2%E7%BB%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E5%88%B0%E5%90%8E%E5%8F%B0/</guid><description>&lt;p&gt;之前一直都是用 screen 来后台运行 Linux 进程，但是 screen 对于已经在运行的进程就不方便处理了，这个时候怎么办呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol start="0"&gt;
&lt;li&gt;Run some &lt;strong&gt;SOMECOMMAND&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;1.** ctrl+z **to stop (pause) the program and get back to the shell&lt;/li&gt;
&lt;li&gt;2. &lt;strong&gt;bg&lt;/strong&gt; to run it in the background&lt;/li&gt;
&lt;li&gt;3. &lt;strong&gt;disown -h&lt;/strong&gt; so that the process isn’t killed when the terminal closes&lt;/li&gt;
&lt;li&gt;
&lt;ol start="4"&gt;
&lt;li&gt;Type **exit **to get out of the shell because now your good to go as the operation will run in the background in it own process so its not tied to a shell&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;套路摘选自下面的连接。&lt;figure class="wp-block-embed"&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="wp-block-embed__wrapper"&gt;
https://sites.google.com/a/kossboss.com/main/linux&amp;#8212;move-running-to-process-nohup
&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;这次训练直接用 bg 结果把自己的任务直接干掉了。。。「sad」。记得用 disown -h 来让任务逃离 「terminal」的控制。&lt;/p&gt;</description></item><item><title>我应该学哪个深度学习框架？</title><link>https://svtter.cn/p/%E6%88%91%E5%BA%94%E8%AF%A5%E5%AD%A6%E5%93%AA%E4%B8%AA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/</link><pubDate>Wed, 02 Jan 2019 01:00:00 +0800</pubDate><guid>https://svtter.cn/p/%E6%88%91%E5%BA%94%E8%AF%A5%E5%AD%A6%E5%93%AA%E4%B8%AA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/</guid><description>&lt;img src="https://i0.wp.com/ws1.sinaimg.cn/large/c53b1907ly1fysk81yoinj21wa0zgael.jpg?w=625&amp;#038;ssl=1" data-recalc-dims="1" /&gt;
&lt;p&gt;答案似乎显然意见 😉&lt;/p&gt;</description></item><item><title>使用 beego 一键生成 API</title><link>https://svtter.cn/p/%E4%BD%BF%E7%94%A8-beego-%E4%B8%80%E9%94%AE%E7%94%9F%E6%88%90-api/</link><pubDate>Fri, 28 Dec 2018 01:00:00 +0800</pubDate><guid>https://svtter.cn/p/%E4%BD%BF%E7%94%A8-beego-%E4%B8%80%E9%94%AE%E7%94%9F%E6%88%90-api/</guid><description>&lt;p&gt;首先要吐槽一点：beego 的文档对于新手实在是太不友好了。&lt;/p&gt;
&lt;p&gt;beego 的官方文档会出现一些问题，比如 tutorials 里面，应该是 &lt;code&gt;beego run&lt;/code&gt; 而不是 &lt;code&gt;beego run hello&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id="beego-是啥"&gt;beego 是啥
&lt;/h2&gt;&lt;p&gt;beego 是 golang 的一个 web 开发框架，集成了不少远 golang 没有的有价值的函数，对于快速开发高性能的 go 应用有不少帮助。&lt;/p&gt;
&lt;p&gt;如果想开发简单的 go 应用，其实可以不使用 golang 框架，因为 go 本身就定义为云计算时代 C 语言，很多功能其实以及包含了，没有必要学习一个框架给自己增加不必要的麻烦。&lt;/p&gt;
&lt;h2 id="生成-api-以及相关代码"&gt;生成 API 以及相关代码
&lt;/h2&gt;&lt;p&gt;beego 生成数据库相关的 API 十分简单，对于一些很简单的站可以很简单粗暴。首先，设计好数据库表：通过 adminer，或者 phpmy* 这些类似的东西都可以设计。如果想做的专业一点，可以用更酷的东西，比如 Powerdesigner 等。但是一般情况下，我想没人搞得这么麻烦。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bee api orm_test -driver=mysql -conn=&amp;quot;root:example@/orm_ets?charset=utf8&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;运行这个命令，将会生成一个项目，里面包含&lt;code&gt;orm_test&lt;/code&gt;的所有 Model。&lt;/p&gt;
&lt;h2 id="生成文档"&gt;生成文档
&lt;/h2&gt;&lt;p&gt;调用 &lt;code&gt;bee run -gendoc=true -downdoc=true&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="参考"&gt;参考&lt;figure class="wp-block-embed is-type-rich is-provider-嵌入处理程序"&gt;
&lt;/h2&gt;&lt;div class="wp-block-embed__wrapper"&gt;
https://blog.csdn.net/freewebsys/article/details/69486943
&lt;/div&gt;&lt;/figure&gt;</description></item><item><title>迁移 Django Model id 为 uuid</title><link>https://svtter.cn/p/%E8%BF%81%E7%A7%BB-django-model-id-%E4%B8%BA-uuid/</link><pubDate>Thu, 06 Dec 2018 01:00:00 +0800</pubDate><guid>https://svtter.cn/p/%E8%BF%81%E7%A7%BB-django-model-id-%E4%B8%BA-uuid/</guid><description>&lt;blockquote&gt;
&lt;p&gt;&lt;a class="link" href="https://www.klette.us/migrate-django-models-to-uuid-primary-key/" target="_blank" rel="noopener"
&gt;https://www.klette.us/migrate-django-models-to-uuid-primary-key/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;又是一篇渣翻&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;老设计决策有时候会让你很难受，下面就是一个例子。&lt;/p&gt;
&lt;p&gt;我手上的一个 Django Model 是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=" language-python"&gt;&amp;lt;span class="token keyword"&gt;class&amp;lt;/span&gt; &amp;lt;span class="token class-name"&gt;Municipality&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;models&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;Model&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;:&amp;lt;/span&gt;
code &amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt; models&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;CharField&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;max_length&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;&amp;lt;span class="token number"&gt;2&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt; primary_key&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;&amp;lt;span class="token boolean"&gt;True&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;
name &amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt; models&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;CharField&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;max_length&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;&amp;lt;span class="token number"&gt;100&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此外，还有一个外键指向它&lt;/p&gt;
&lt;pre class=" language-python"&gt;&lt;code class=" language-python"&gt;&amp;lt;span class="token keyword"&gt;class&amp;lt;/span&gt; &amp;lt;span class="token class-name"&gt;ZipCode&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;models&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;Model&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;:&amp;lt;/span&gt;
code &amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt; models&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;CharField&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;max_length&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;&amp;lt;span class="token number"&gt;2&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt; primary_key&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;&amp;lt;span class="token boolean"&gt;True&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;
municipality &amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt; models&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;ForeignKey&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;Municipality&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，我们需要让 municipality 支持多个国家，显然一个唯一 field 将会引起冲突，不够用。（译者：这个理由有点牵强）&lt;/p&gt;
&lt;p&gt;对于所有代码的现代部分，我们使用&lt;code&gt;UUID&lt;/code&gt;作为主键。所以我们想要 migrate &lt;code&gt;municaipality&lt;/code&gt;的主键到&lt;code&gt;UUID&lt;/code&gt;，并且维持了原有的关系。（译者：外键和自增主键都是数据库性能的杀手。）&lt;/p&gt;
&lt;p&gt;2017年9月份，Django 依然不支持优雅的迁移主键，所以我们自己做了（译者：我也不知道现在行不行。）&lt;/p&gt;
&lt;p&gt;我们尝试了许多 magic 解决方案，但是我们在 migrations 系统这个被难住了，并且不能检测以及很好的处理改变。&lt;/p&gt;
&lt;p&gt;在经过一小段研究和错误，我们找到了以下的解决方案。尽管这还有一些小问题，但是的确有效。&lt;/p&gt;
&lt;p&gt;再一次提醒，从数据库的角度，当你定义了一个&lt;code&gt;ForeignKey&lt;/code&gt; field 在 Django 中，Django将会创建一个数据库列，是同样的类型，作为 referenced model 的主键，并且增加外键约束。所以在上面的例子中，我们有两个表：&lt;/p&gt;
&lt;pre class=" language-sql"&gt;&lt;code class=" language-sql"&gt;&amp;lt;span class="token keyword"&gt;CREATE&amp;lt;/span&gt; &amp;lt;span class="token keyword"&gt;TABLE&amp;lt;/span&gt; municipality &amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;
code &amp;lt;span class="token keyword"&gt;varchar&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;&amp;lt;span class="token number"&gt;2&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt; &amp;lt;span class="token keyword"&gt;PRIMARY&amp;lt;/span&gt; &amp;lt;span class="token keyword"&gt;KEY&amp;lt;/span&gt; &amp;lt;span class="token operator"&gt;NOT&amp;lt;/span&gt; &amp;lt;span class="token boolean"&gt;NULL&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt;
name &amp;lt;span class="token keyword"&gt;varchar&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;&amp;lt;span class="token number"&gt;100&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;
&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;;&amp;lt;/span&gt;
&amp;lt;span class="token keyword"&gt;CREATE&amp;lt;/span&gt; &amp;lt;span class="token keyword"&gt;TABLE&amp;lt;/span&gt; zipcode &amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;
code &amp;lt;span class="token keyword"&gt;varchar&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;&amp;lt;span class="token number"&gt;2&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt; &amp;lt;span class="token keyword"&gt;PRIMARY&amp;lt;/span&gt; &amp;lt;span class="token keyword"&gt;KEY&amp;lt;/span&gt; &amp;lt;span class="token operator"&gt;NOT&amp;lt;/span&gt; &amp;lt;span class="token boolean"&gt;NULL&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt;
municipality_id &amp;lt;span class="token keyword"&gt;VARCHAR&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;&amp;lt;span class="token number"&gt;2&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt; &amp;lt;span class="token keyword"&gt;REFERENCES&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;municipality&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;id&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt; &amp;lt;span class="token operator"&gt;NOT&amp;lt;/span&gt; &amp;lt;span class="token boolean"&gt;NULL&amp;lt;/span&gt;
&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;;&amp;lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以我们需要解除外键约束，更换 root model，然后映射新的主键到旧的上，并且重新应用外键到上面去。&lt;/p&gt;
&lt;p&gt;我们首先打破外键&lt;/p&gt;
&lt;pre class=" language-python"&gt;&lt;code class=" language-python"&gt;&amp;lt;span class="token keyword"&gt;class&amp;lt;/span&gt; &amp;lt;span class="token class-name"&gt;ZipCode&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;models&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;Model&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;:&amp;lt;/span&gt;
code &amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt; &amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt; &amp;lt;span class="token comment" spellcheck="true"&gt;# Same as before&amp;lt;/span&gt;
municipality &amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt; models&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;CharField&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;max_length&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;&amp;lt;span class="token number"&gt;2&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=" language-sh"&gt;&lt;code&gt;python manage.py makemigrations -n break_zipcode_muni_foreignkey&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，·Municipality·modle 没有被任何外键所 refer，我们可以在上面进行工作了。&lt;/p&gt;
&lt;p&gt;增加一个新的 id field：&lt;/p&gt;
&lt;pre class=" language-python"&gt;&lt;code class=" language-python"&gt;&amp;lt;span class="token keyword"&gt;class&amp;lt;/span&gt; &amp;lt;span class="token class-name"&gt;Municipality&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;models&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;Model&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;:&amp;lt;/span&gt;
id &amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt; models&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;UUIDField&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;default&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;uuid&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;uuid4&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=" language-sh"&gt;&lt;code&gt;python manage.py makemigrations -n add_id_field_to_muni&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;处于某些原因，默认值在我的案例中不 work，所以我增加了一个过程到创建的 migration，来创建新的唯一 id。&lt;/p&gt;
&lt;pre class=" language-python"&gt;&lt;code class=" language-python"&gt;&amp;lt;span class="token keyword"&gt;def&amp;lt;/span&gt; &amp;lt;span class="token function"&gt;create_ids&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;apps&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt; schema_editor&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;:&amp;lt;/span&gt;
Municipality &amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt; apps&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;get_model&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;&amp;lt;span class="token string"&gt;'loc'&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt; &amp;lt;span class="token string"&gt;'Municipality'&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;
&amp;lt;span class="token keyword"&gt;for&amp;lt;/span&gt; m &amp;lt;span class="token keyword"&gt;in&amp;lt;/span&gt; municipality&amp;lt;span class="token punctuation"&gt;:&amp;lt;/span&gt;
m&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;id &amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt; uuid&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;uuid4&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;
m&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;save&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;
&amp;lt;span class="token comment" spellcheck="true"&gt;# ...&amp;lt;/span&gt;
operations &amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt; &amp;lt;span class="token punctuation"&gt;[&amp;lt;/span&gt;
migrations&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;AddField&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt;
migrations&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;RunPython&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;code&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;create_ids&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt;
&amp;lt;span class="token punctuation"&gt;]&amp;lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在我们有一个&lt;code&gt;UUID&lt;/code&gt; ·id·field 在·Municipality 中，然后我们应该可以更换主键了。&lt;/p&gt;
&lt;pre class=" language-python"&gt;&lt;code class=" language-python"&gt;&amp;lt;span class="token keyword"&gt;class&amp;lt;/span&gt; &amp;lt;span class="token class-name"&gt;Municipality&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;models&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;Model&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;:&amp;lt;/span&gt;
id &amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt; models&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;UUIDField&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;default&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;uuid&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;uuid4&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt; primary_key&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;&amp;lt;span class="token boolean"&gt;True&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;
code &amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt; models&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;CharField&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;max_length&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;&amp;lt;span class="token number"&gt;2&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt; unique&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;&amp;lt;span class="token boolean"&gt;True&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建 migration，并且确保在&lt;code&gt;code&lt;/code&gt;上的&lt;code&gt;AlterField&lt;/code&gt;操作在&lt;code&gt;id&lt;/code&gt;之前。我们已经在&lt;code&gt;id&lt;/code&gt;上增加了&lt;code&gt;primary_key&lt;/code&gt;并且增加了 unique=True 到&lt;code&gt;code&lt;/code&gt; field。constraint 没了，在我们删除 primary_key 的时候就没了。&lt;/p&gt;
&lt;p&gt;让我们开始一个空的迁移&lt;/p&gt;
&lt;pre class=" language-sh"&gt;&lt;code&gt;python manage.py makemigrations --empty -n fix_zipcode_fk_to_muni_uuid loc&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打开文件，输入&lt;/p&gt;
&lt;pre class=" language-python"&gt;&lt;code class=" language-python"&gt;&amp;lt;span class="token keyword"&gt;def&amp;lt;/span&gt; &amp;lt;span class="token function"&gt;match&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;apps&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt; schema_editor&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;:&amp;lt;/span&gt;
ZipCode &amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt; apps&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;get_model&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;&amp;lt;span class="token string"&gt;'loc'&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt; &amp;lt;span class="token string"&gt;'ZipCode'&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;
Muni &amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt; apps&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;get_model&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;&amp;lt;span class="token string"&gt;'loc'&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt; &amp;lt;span class="token string"&gt;'Municipality'&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;
&amp;lt;span class="token keyword"&gt;for&amp;lt;/span&gt; zip_code &amp;lt;span class="token keyword"&gt;in&amp;lt;/span&gt; ZipCode&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;object&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;all&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;:&amp;lt;/span&gt;
zip_code&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;temp_muni &amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt; Muni&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;get&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;code&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;z&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;municipality&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;
zip_code&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;save&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;
&amp;lt;span class="token comment" spellcheck="true"&gt;# ...&amp;lt;/span&gt;
operations &amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt; &amp;lt;span class="token punctuation"&gt;[&amp;lt;/span&gt;
migrations&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;AddField&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;
model_name&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;&amp;lt;span class="token string"&gt;'zipcode'&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt;
name&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;&amp;lt;span class="token string"&gt;'temp_muni'&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt;
field&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;models&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;UUIDField&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;null&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;&amp;lt;span class="token boolean"&gt;True&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt;
&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt;
migrations&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;RunPython&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;code&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;match&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt;
migrations&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;RemoveField&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;model_name&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;&amp;lt;span class="token string"&gt;'zipcode'&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt; name&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;&amp;lt;span class="token string"&gt;'municipality'&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt;
migrations&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;RenameField&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;
model_name&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;&amp;lt;span class="token string"&gt;'zipcode'&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt; old_name&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;&amp;lt;span class="token string"&gt;'temp_muni'&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt; new_name&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;&amp;lt;span class="token string"&gt;'municipality'&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt;
migrations&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;AlterField&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;
model_name&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;&amp;lt;span class="token string"&gt;'zipcode'&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt;
name&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;&amp;lt;span class="token string"&gt;'municipality'&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt;
field&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;models&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;ForeignKey&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;
on_delete&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;django&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;db&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;models&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;deletion&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;PROTECT&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt;
to&amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt;&amp;lt;span class="token string"&gt;'municipality'&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;
&amp;lt;span class="token punctuation"&gt;]&amp;lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;增加一个临时的field来保存 Municipality 的UUID，我们不让他是一个&lt;code&gt;ForeignKey&lt;/code&gt;field，否则 Django confuse。&lt;/li&gt;
&lt;li&gt;我们运行 match 函数来寻找新的 id，通过寻找旧的 key，并且存储到临时的 field。&lt;/li&gt;
&lt;li&gt;删除旧的 municipality field&lt;/li&gt;
&lt;li&gt;重命名临时 field 到 municipality&lt;/li&gt;
&lt;li&gt;最后迁移到一个外键，然后创建我们需要 constraint&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;译者：这样改最大的好处就是改了 UUID，但是没有破坏之前的逻辑，可以说是谨慎的迁移吧。不过线上的数据既然在跑着，就这么迁移了，会不会出问题呢。&lt;/pre&gt;
&lt;p&gt;下面还有一些内容。自从我们将 migrations 分离成多个文件，我们让代码变得很脆弱（如果后面的某些 migrations 失败了）。这将会让我们的应用进入一个 unworkable 的状态。所以确保测试一下migrations。你可通过手工把这所有的步骤整合到一个migration里，但是如果你有来自多个不同app的 reference，你可能需要把这些步骤再分开。&lt;/p&gt;
&lt;h2 id="logging"&gt;logging
&lt;/h2&gt;&lt;p&gt;迁移的过程中，你可能遇到很多问题，所以一个比较不错的方式，是创建一个简单的迁移 logging。&lt;/p&gt;
&lt;pre class=" language-python"&gt;&lt;code class=" language-python"&gt;&amp;lt;span class="token keyword"&gt;def&amp;lt;/span&gt; &amp;lt;span class="token function"&gt;log&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;message&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;:&amp;lt;/span&gt;
&amp;lt;span class="token keyword"&gt;def&amp;lt;/span&gt; &amp;lt;span class="token function"&gt;fake_op&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;apps&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt; schema_editor&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;:&amp;lt;/span&gt;
&amp;lt;span class="token keyword"&gt;print&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;message&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;
&amp;lt;span class="token keyword"&gt;return&amp;lt;/span&gt; fake_op
&amp;lt;span class="token comment" spellcheck="true"&gt;# ...&amp;lt;/span&gt;
operations &amp;lt;span class="token operator"&gt;=&amp;lt;/span&gt; &amp;lt;span class="token punctuation"&gt;[&amp;lt;/span&gt;
migration&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;RunPython&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;log&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;&amp;lt;span class="token string"&gt;'Step 1'&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt;
migration&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;AlterField&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt;
migration&amp;lt;span class="token punctuation"&gt;.&amp;lt;/span&gt;RunPython&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;log&amp;lt;span class="token punctuation"&gt;(&amp;lt;/span&gt;&amp;lt;span class="token string"&gt;'Step 2'&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;)&amp;lt;/span&gt;&amp;lt;span class="token punctuation"&gt;,&amp;lt;/span&gt;
&amp;lt;span class="token comment" spellcheck="true"&gt;# ...&amp;lt;/span&gt;
&amp;lt;span class="token punctuation"&gt;]&amp;lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;想要观察 Django 运行了那些 SQL 语句，运行&lt;code&gt;python manage.py sqlmigrate &amp;lt;appname&amp;gt;&amp;lt;migration_number&amp;gt;&lt;/code&gt;，这是一个超级有用的方法。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;</description></item><item><title>Pycharm Tips</title><link>https://svtter.cn/p/pycharm-tips/</link><pubDate>Mon, 12 Nov 2018 01:00:00 +0800</pubDate><guid>https://svtter.cn/p/pycharm-tips/</guid><description>&lt;p&gt;最近使用 Pycharm ，有时候引用包的时候很不方便，错误的显示 package 不存在。出现这个问题的本质是因为：代码检查的位置没有设置好。&lt;/p&gt;
&lt;p&gt;那么怎么解决这个问题呢？偶尔发现 Pycharm 的选项中，有一个选项是marked，因此选 marked 即可。&lt;/p&gt;
&lt;p&gt;还有就是 Docker 的配置，以及 Python interpreter的配置。这两个都可以通过设置进行配置，然后修改默认的 Python 解释器。在 Python interpreter 中，还可以手动安装相关的包。&lt;/p&gt;
&lt;h2 id="使用-vim"&gt;使用 Vim
&lt;/h2&gt;&lt;p&gt;使用 ideavim，可以将原来的按键映射到 Vim 按键上。&lt;/p&gt;
&lt;p&gt;（有新的就更新。）&lt;/p&gt;
&lt;h2 id="使用-docker-compose"&gt;使用 Docker-compose&lt;figure class="wp-block-embed"&gt;
&lt;/h2&gt;&lt;div class="wp-block-embed__wrapper"&gt;
https://www.jetbrains.com/help/pycharm/using-docker-compose-as-a-remote-interpreter.html
&lt;/div&gt;&lt;/figure&gt;
&lt;h2 id="查看文件结构"&gt;查看文件结构&lt;figure class="wp-block-embed"&gt;
&lt;/h2&gt;&lt;div class="wp-block-embed__wrapper"&gt;
https://www.v2ex.com/t/261934
&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;点击左下角的 structure 即可。&lt;/p&gt;
&lt;p&gt;转载请注明出处。&lt;/p&gt;</description></item><item><title>Python functools</title><link>https://svtter.cn/p/python-functools/</link><pubDate>Sun, 21 Oct 2018 01:00:00 +0800</pubDate><guid>https://svtter.cn/p/python-functools/</guid><description>&lt;p&gt;Python &lt;a class="link" href="https://docs.python.org/3/library/functools.html" target="_blank" rel="noopener"
&gt;functools&lt;/a&gt;包中，有个很好的函数叫做&lt;code&gt;partial&lt;/code&gt; ，中文直接翻译为&lt;code&gt;片函数&lt;/code&gt;，此前一直都没有使用过。最近通过阅读别人的代码，学会了这一技能，着实好用。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;partial&lt;/code&gt;，可以把一些固有功能代码做一个整合；&lt;/p&gt;
&lt;p&gt;比如我希望一个函数专门做 int2 转换&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;int2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;partial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;甚至还可以再过分一点，把 base 变成一个字典量传入。&lt;/p&gt;
&lt;p&gt;多使用内建函数 locals，可以极大的减少自己的代码量；&lt;/p&gt;
&lt;p&gt;这不得不让我感概：真正的 Pythonista，永无止境。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;in_func&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="nb"&gt;locals&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="changelog"&gt;CHANGELOG
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left"&gt;date&lt;/th&gt;
&lt;th style="text-align: left"&gt;content&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;20230829&lt;/td&gt;
&lt;td style="text-align: left"&gt;调整了一些语病&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description></item><item><title>笔记列表</title><link>https://svtter.cn/p/%E7%AC%94%E8%AE%B0%E5%88%97%E8%A1%A8/</link><pubDate>Fri, 30 Mar 2018 01:00:00 +0800</pubDate><guid>https://svtter.cn/p/%E7%AC%94%E8%AE%B0%E5%88%97%E8%A1%A8/</guid><description>&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="https://sphinx-learn.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener"
&gt;sphinx-learn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="http://algorithm-note.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener"
&gt;algorithm_note&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="http://python-note.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener"
&gt;python_note&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些笔记用 Sphinx 进行书写的，Sphinx 着实不是特别好用，学习曲线有些陡峭，后面打算切换到语雀什么的，可能会舒服一些。就是可能不够自由。&lt;/p&gt;
&lt;p&gt;如果喜欢本博客，建议添加 RSS 订阅&lt;/p&gt;</description></item><item><title>UML – 学习笔记</title><link>https://svtter.cn/p/uml-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link><pubDate>Tue, 30 Jun 2015 01:00:00 +0800</pubDate><guid>https://svtter.cn/p/uml-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid><description>&lt;h2 id="用例图"&gt;用例图
&lt;/h2&gt;&lt;p&gt;扩展和包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;扩展(extend)： extend关系是对基用例的扩展，&lt;strong&gt;基用例是一个完整的用例，即使没有子用例的参与，也可以完成一个完整的功能&lt;/strong&gt;。extend的基用例中将存在一个扩展点，只有当扩展点被激活时，子用例才会被执行。 extend关系在用例图中使用带箭头的虚线表示(在线上标注&amp;laquo;extend&amp;raquo;)，&lt;strong&gt;箭头从子用例指向基用例&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;包含(include)： include为包含关系，当两个或多个用例中共用一组相同的动作，这时可以将这组相同的动作抽出来作为一个独立的子用例，供多个基用例所共享。因为子用例被抽出，基用例并非一个完整的用例，所以&lt;strong&gt;include关系中的基用例必须和子用例一起使用才够完整，子用例也必然被执行&lt;/strong&gt;。include关系在用例图中使用带箭头的虚线表示(在线上标注&amp;laquo;include&amp;raquo;)，箭头&lt;strong&gt;从基用例指向子用例&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="设计模式"&gt;设计模式
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;参考的学习资料：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="http://peterwei.iteye.com/blog/958803" target="_blank" rel="noopener"
&gt;http://peterwei.iteye.com/blog/958803&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="http://design-patterns.readthedocs.org/zh_CN/latest/creational_patterns/creational.html" target="_blank" rel="noopener"
&gt;图说设计模式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>近期算法笔记</title><link>https://svtter.cn/p/%E8%BF%91%E6%9C%9F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</link><pubDate>Fri, 08 May 2015 01:00:00 +0800</pubDate><guid>https://svtter.cn/p/%E8%BF%91%E6%9C%9F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</guid><description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class="link" href="http://argcv.com/articles/72.c" target="_blank" rel="noopener"
&gt;算法书籍&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;莫队算法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最大团&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最短路&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A _搜索算法——图形搜索算法，从给定起点到给定终点计算出路径。其中使用了一种启发式的估算，为每个节点估算通过该节点的最佳路径，并以之为各个地点排定次序。算法以得到的次序访问这些节点。因此，A_搜索算法是最佳优先搜索的范例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集束搜索（又名定向搜索，Beam Search）——最佳优先搜索算法的优化。使用启发式函数评估它检查的每个节点的能力。不过，集束搜索只能在每个深度中发现最前面的m个最符合条件的节点，m是固定数字——集束的宽度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二分查找（Binary Search）——在线性数组中找特定值的算法，每个步骤去掉一半不符合要求的数据。&lt;/p&gt;
&lt;p&gt;分支界定算法（Branch and Bound）——在多种最优化问题中寻找特定最优化解决方案的算法，特别是针对离散、组合的最优化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Buchberger算法——一种数学算法，可将其视为针对单变量最大公约数求解的欧几里得算法和线性系统中高斯消元法的泛化。&lt;/p&gt;
&lt;p&gt;数据压缩——采取特定编码方案，使用更少的字节数（或是其他信息承载单元）对信息编码的过程，又叫来源编码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Diffie-Hellman密钥交换算法——一种加密协议，允许双方在事先不了解对方的情况下，在不安全的通信信道中，共同建立共享密钥。该密钥以后可与一个对称密码一起，加密后续通讯。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dijkstra算法——针对没有负值权重边的有向图，计算其中的单一起点最短算法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;离散微分算法（Discrete differentiation）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态规划算法（Dynamic Programming）——展示互相覆盖的子问题和最优子架构算法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;欧几里得算法（Euclidean algorithm）——计算两个整数的最大公约数。最古老的算法之一，出现在公元前300前欧几里得的《几何原本》。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;期望-最大算法（Expectation-maximization algorithm，又名EM-Training）——在统计计算中，期望-最大算法在概率模型中寻找可能性最大的参数估算值，其中模型依赖于未发现的潜在变量。EM在两个步骤中交替计算，第一步是计算期望，利用对隐藏变量的现有估计值，计算其最大可能估计值；第二步是最大化，最大化在第一步上求得的最大可能值来计算参数的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快速傅里叶变换（Fast Fourier transform，FFT）——计算离散的傅里叶变换（DFT）及其反转。该算法应用范围很广，从数字信号处理到解决偏微分方程，到快速计算大整数乘积。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;梯度下降（Gradient descent）——一种数学上的最优化算法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哈希算法（Hashing）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;堆排序（Heaps）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Karatsuba乘法——需要完成上千位整数的乘法的系统中使用，比如计算机代数系统和大数程序库，如果使用长乘法，速度太慢。该算法发现于1962年。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LLL算法（Lenstra-Lenstra-Lovasz lattice reduction）——以格规约（lattice）基数为输入，输出短正交向量基数。LLL算法在以下公共密钥加密方法中有大量使用：背包加密系统（knapsack）、有特定设置的RSA加密等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最大流量算法（Maximum flow）——该算法试图从一个流量网络中找到最大的流。它优势被定义为找到这样一个流的值。最大流问题可以看作更复杂的网络流问题的特定情况。最大流与网络中的界面有关，这就是最大流-最小截定理（Max-flow min-cut theorem）。Ford-Fulkerson 能找到一个流网络中的最大流。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;合并排序（Merge Sort）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;牛顿法（Newton’s method）——求非线性方程（组）零点的一种重要的迭代法。&lt;/p&gt;
&lt;p&gt;Q-learning学习算法——这是一种通过学习动作值函数（action-value function）完成的强化学习算法，函数采取在给定状态的给定动作，并计算出期望的效用价值，在此后遵循固定的策略。Q-leanring的优势是，在不需要环境模型的情况下，可以对比可采纳行动的期望效用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两次筛法（Quadratic Sieve）——现代整数因子分解算法，在实践中，是目前已知第二快的此类算法（仅次于数域筛法Number Field Sieve）。对于110位以下的十位整数，它仍是最快的，而且都认为它比数域筛法更简单。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RANSAC——是“RANdom SAmple Consensus”的缩写。该算法根据一系列观察得到的数据，数据中包含异常值，估算一个数学模型的参数值。其基本假设是：数据包含非异化值，也就是能够通过某些模型参数解释的值，异化值就是那些不符合模型的数据点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RSA——公钥加密算法。首个适用于以签名作为加密的算法。RSA在电商行业中仍大规模使用，大家也相信它有足够安全长度的公钥。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Schönhage-Strassen算法——在数学中，Schönhage-Strassen算法是用来完成大整数的乘法的快速渐近算法。其算法复杂度为：O(N log(N) log(log(N)))，该算法使用了傅里叶变换。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单纯型算法（Simplex Algorithm）——在数学的优化理论中，单纯型算法是常用的技术，用来找到线性规划问题的数值解。线性规划问题包括在一组实变量上的一系列线性不等式组，以及一个等待最大化（或最小化）的固定线性函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;奇异值分解（Singular value decomposition，简称SVD）——在线性代数中，SVD是重要的实数或复数矩阵的分解方法，在信号处理和统计中有多种应用，比如计算矩阵的伪逆矩阵（以求解最小二乘法问题）、解决超定线性系统（overdetermined linear systems）、矩阵逼近、数值天气预报等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;求解线性方程组（Solving a system of linear equations）——线性方程组是数学中最古老的问题，它们有很多应用，比如在数字信号处理、线性规划中的估算和预测、数值分析中的非线性问题逼近等等。求解线性方程组，可以使用高斯—约当消去法（Gauss-Jordan elimination），或是柯列斯基分解（ Cholesky decomposition）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Strukturtensor算法——应用于模式识别领域，为所有像素找出一种计算方法，看看该像素是否处于同质区域（ homogenous region），看看它是否属于边缘，还是是一个顶点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;合并查找算法（Union-find）——给定一组元素，该算法常常用来把这些元素分为多个分离的、彼此不重合的组。不相交集（disjoint-set）的数据结构可以跟踪这样的切分方法。合并查找算法可以在此种数据结构上完成两个有用的操作：&lt;/p&gt;
&lt;p&gt;查找：判断某特定元素属于哪个组。&lt;/p&gt;
&lt;p&gt;合并：联合或合并两个组为一个组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;维特比算法（Viterbi algorithm）——寻找隐藏状态最有可能序列的动态规划算法，这种序列被称为维特比路径，其结果是一系列可以观察到的事件，特别是在隐藏的Markov模型中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>