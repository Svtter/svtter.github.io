<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>学习 on Svtter&#39;s Blog</title>
    <link>http://192.168.2.39:1313/categories/%E5%AD%A6%E4%B9%A0/</link>
    <description>Recent content in 学习 on Svtter&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 12 Mar 2019 01:00:00 +0800</lastBuildDate>
    <atom:link href="http://192.168.2.39:1313/categories/%E5%AD%A6%E4%B9%A0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>关于分享这件事</title>
      <link>http://192.168.2.39:1313/?p=589/</link>
      <pubDate>Tue, 12 Mar 2019 01:00:00 +0800</pubDate>
      <guid>http://192.168.2.39:1313/?p=589/</guid>
      <description>我一直都是相对喜欢分享的，但是我不喜欢分享给那些不懂得分享的人。&#xA;比如如果我们是开源的，我们就不喜欢那些闭源公司。这对于我们不公平。他们拿走了我们的成果。</description>
    </item>
    <item>
      <title>编程语言与知识基础</title>
      <link>http://192.168.2.39:1313/2019/01/31/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%9F%A5%E8%AF%86%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 31 Jan 2019 01:00:00 +0800</pubDate>
      <guid>http://192.168.2.39:1313/2019/01/31/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%9F%A5%E8%AF%86%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;p&gt;随着一部分编程经验的增长，我越来越觉得，程序设计语言是在知识基础上实现应用的工具。&lt;/p&gt;</description>
    </item>
    <item>
      <title>将已经运行的进程切换到后台</title>
      <link>http://192.168.2.39:1313/2019/01/17/%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C-linux-%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Thu, 17 Jan 2019 01:00:00 +0800</pubDate>
      <guid>http://192.168.2.39:1313/2019/01/17/%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C-linux-%E8%BF%9B%E7%A8%8B/</guid>
      <description>之前一直都是用 screen 来后台运行 Linux 进程，但是 screen 对于已经在运行的进程就不方便处理了，这个时候怎么办呢？&#xA;Run some SOMECOMMAND 1.** ctrl+z **to stop (pause) the program and get back to the shell 2. bg to run it in the background 3. disown -h so that the process isn’t killed when the terminal closes Type **exit **to get out of the shell because now your good to go as the operation will run in the background in it own process so its not tied to a shell 套路摘选自下面的连接。 这次训练直接用 bg 结果把自己的任务直接干掉了。。。「sad」。记得用 disown -h 来让任务逃离 「terminal」的控制。</description>
    </item>
    <item>
      <title>我应该学哪个深度学习框架？</title>
      <link>http://192.168.2.39:1313/2019/01/02/%E6%88%91%E5%BA%94%E8%AF%A5%E5%AD%A6%E5%93%AA%E4%B8%AA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%EF%BC%9F/</link>
      <pubDate>Wed, 02 Jan 2019 01:00:00 +0800</pubDate>
      <guid>http://192.168.2.39:1313/2019/01/02/%E6%88%91%E5%BA%94%E8%AF%A5%E5%AD%A6%E5%93%AA%E4%B8%AA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%EF%BC%9F/</guid>
      <description>答案似乎显然意见 😉</description>
    </item>
    <item>
      <title>表达能力的重要性</title>
      <link>http://192.168.2.39:1313/?p=533/</link>
      <pubDate>Fri, 28 Dec 2018 01:00:00 +0800</pubDate>
      <guid>http://192.168.2.39:1313/?p=533/</guid>
      <description>大家从事计算机工作的，可能都没有意识到一个问题：我们的表达能力可能有所不足。&#xA;诚然，PPT是一个很好的表达方式，但是很多人都不使用；甚至有些人完全看不起PPT之类的表达方式，甚至觉得自己是“孤胆英雄”——这是绝对有问题的。笔者之前就犯过这样的错误，觉得自己什么都能做，自己也可以在自己的某个角落，辛苦耕耘，然后创造出大作，改变世界。&#xA;现在看来，并不现实。&#xA;起码在笔者身上不行。笔者也不认为有人可以一下子拿出一个所谓的大作。Linus 是大家公认的“大神”，但是 Linux 诞生之初，也不是一个那么耀眼可以横扫一切的东西，换言之，Linux是一个高效团队协作的结晶。&#xA;笔者不否认天才的存在。但是大多数人需要考虑的问题是，我是不是天才。很明显，芸芸众生，天才的数量少之又少，而就算是天才，仲永之流也不在少数。因此，天才也是需要团队合作，进而需要交流的。&#xA;表达能力，沟通能力到了，自然与别人交流的效率就高了。最高的赞赏莫过于，别人觉得你这个人靠谱。&#xA;笔者行文之余，也发现自己的表达不够清晰。</description>
    </item>
    <item>
      <title>使用 beego 一键生成 API</title>
      <link>http://192.168.2.39:1313/2018/12/28/%E4%BD%BF%E7%94%A8-beego-%E4%B8%80%E9%94%AE%E7%94%9F%E6%88%90-api/</link>
      <pubDate>Fri, 28 Dec 2018 01:00:00 +0800</pubDate>
      <guid>http://192.168.2.39:1313/2018/12/28/%E4%BD%BF%E7%94%A8-beego-%E4%B8%80%E9%94%AE%E7%94%9F%E6%88%90-api/</guid>
      <description>&lt;p&gt;首先要吐槽一点：beego 的文档对于新手实在是太不友好了。&lt;/p&gt;&#xA;&lt;p&gt;beego 的官方文档会出现一些问题，比如 tutorials 里面，应该是 &lt;code&gt;beego run&lt;/code&gt; 而不是 &lt;code&gt;beego run hello&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;beego-是啥&#34;&gt;beego 是啥&lt;/h2&gt;&#xA;&lt;p&gt;beego 是 golang 的一个 web 开发框架，集成了不少远 golang 没有的有价值的函数，对于快速开发高性能的 go 应用有不少帮助。&lt;/p&gt;&#xA;&lt;p&gt;如果想开发简单的 go 应用，其实可以不使用 golang 框架，因为 go 本身就定义为云计算时代 C 语言，很多功能其实以及包含了，没有必要学习一个框架给自己增加不必要的麻烦。&lt;/p&gt;</description>
    </item>
    <item>
      <title>后端技术想法</title>
      <link>http://192.168.2.39:1313/?p=537/</link>
      <pubDate>Thu, 27 Dec 2018 01:00:00 +0800</pubDate>
      <guid>http://192.168.2.39:1313/?p=537/</guid>
      <description>分享一些不成熟的想法。&#xA;个人认为以后很麻烦的自己配置nginx全家桶的python开发模式肯定会越来越少，既然想要做企业，做创业，那么就从 k8s 走起。</description>
    </item>
    <item>
      <title>WEB developers next station</title>
      <link>http://192.168.2.39:1313/?p=536/</link>
      <pubDate>Mon, 24 Dec 2018 01:00:00 +0800</pubDate>
      <guid>http://192.168.2.39:1313/?p=536/</guid>
      <description></description>
    </item>
    <item>
      <title>迁移 Django Model id 为 uuid</title>
      <link>http://192.168.2.39:1313/2018/12/06/%E8%BF%81%E7%A7%BB-django-model-id-%E4%B8%BA-uuid/</link>
      <pubDate>Thu, 06 Dec 2018 01:00:00 +0800</pubDate>
      <guid>http://192.168.2.39:1313/2018/12/06/%E8%BF%81%E7%A7%BB-django-model-id-%E4%B8%BA-uuid/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.klette.us/migrate-django-models-to-uuid-primary-key/&#34;&gt;https://www.klette.us/migrate-django-models-to-uuid-primary-key/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;又是一篇渣翻&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;老设计决策有时候会让你很难受，下面就是一个例子。&lt;/p&gt;</description>
    </item>
    <item>
      <title>命令行工具整理</title>
      <link>http://192.168.2.39:1313/?p=488/</link>
      <pubDate>Mon, 19 Nov 2018 01:00:00 +0800</pubDate>
      <guid>http://192.168.2.39:1313/?p=488/</guid>
      <description>很奇怪的是，我记得我之前整理过。。&#xA;tldr&#xA;tig&#xA;eog</description>
    </item>
    <item>
      <title>Pycharm Tips</title>
      <link>http://192.168.2.39:1313/2018/11/12/pycharm-tips/</link>
      <pubDate>Mon, 12 Nov 2018 01:00:00 +0800</pubDate>
      <guid>http://192.168.2.39:1313/2018/11/12/pycharm-tips/</guid>
      <description>最近使用 Pycharm ，有时候引用包的时候很不方便，错误的显示 package 不存在。出现这个问题的本质是因为：代码检查的位置没有设置好。&#xA;那么怎么解决这个问题呢？偶尔发现 Pycharm 的选项中，有一个选项是marked，因此选 marked 即可。&#xA;还有就是 Docker 的配置，以及 Python interpreter的配置。这两个都可以通过设置进行配置，然后修改默认的 Python 解释器。在 Python interpreter 中，还可以手动安装相关的包。&#xA;使用 Vim 使用 ideavim，可以将原来的按键映射到 Vim 按键上。&#xA;（有新的就更新。）&#xA;使用 Docker-compose 查看文件结构 点击左下角的 structure 即可。&#xA;转载请注明出处。</description>
    </item>
    <item>
      <title>Python functools</title>
      <link>http://192.168.2.39:1313/post/2018-10-21-python-functools/</link>
      <pubDate>Sun, 21 Oct 2018 01:00:00 +0800</pubDate>
      <guid>http://192.168.2.39:1313/post/2018-10-21-python-functools/</guid>
      <description>Python functools包中，有个很好的函数叫做partial ，中文直接翻译为片函数，此前一直都没有使用过。最近通过阅读别人的代码，学会了这一技能，着实好用。&#xA;使用partial，可以把一些固有功能代码做一个整合；&#xA;比如我希望一个函数专门做 int2 转换&#xA;int2 = partial(int, base=2) 甚至还可以再过分一点，把 base 变成一个字典量传入。&#xA;多使用内建函数 locals，可以极大的减少自己的代码量；&#xA;这不得不让我感概：真正的 Pythonista，永无止境。&#xA;def in_func(): a = 2 b = 3 def test(a, b, **args): return a + b print(test(**locals())) CHANGELOG date content 20230829 调整了一些语病 </description>
    </item>
    <item>
      <title>生活的思考</title>
      <link>http://192.168.2.39:1313/?p=428/</link>
      <pubDate>Sun, 07 Oct 2018 01:00:00 +0800</pubDate>
      <guid>http://192.168.2.39:1313/?p=428/</guid>
      <description>最近读了《人类简史》的又一部分，除了文化相关的内容以外，其他的内容还没有给我很强的冲击力。等完全读完，将书摘之类的分享到博客上。&#xA;这个周末带着女朋友回了家见了一下父母，我也见了她的父母。总体来说双方父母印象都还不错，算是比较顺利，也给了我的生活一些启发。&#xA;一般来讲，笔者比较宅，生活大概都是两点一线的，在读书的时候更是如此。近期做了两个比较大的改变：一个是买了人生中的第一款游戏机，switch，在其中找到了不少快乐；另一个是发现放松不是处处 show hand，简单随意一点更好。&#xA;游戏机的全名是 Nintendo Switch。大概长这个样子：（加上微博图床）。这个游戏机经过多个大佬推荐终于到了我的手里。但是玩起来，说实在的，也没有那么爽。&#xA;前一段时间，看《自控力》比较多，也听了一个知乎的Live，里面对多巴胺提及较多，因此我从多巴胺的角度思考这个问题。这种情况是因为多巴胺让我对这个东西（Switch），进行游戏的满足度的期望值过高，而它给我带来的刺激没有达到我“想象”的那个值，所以我就持续对这个东西进行索求；同样的事情也发生在之前的《PUBG（绝地求生）》，《英雄联盟》上。&#xA;从直接的角度看，出于对游戏以及娱乐时长的不满足，导致我进行游戏的时候总是竭尽全力（包括做其他事情可能也是这样）。从好一点的角度看，我这样十分的专注。但是从不好的角度看，这说明我无法同时完成多个事情。&#xA;我发现优秀的人是在享受游戏，而不是像我一样追求游戏最后带来的某种东西， 或者说是追求最后的那个结果。这才是在享受游戏。&#xA;不应使用不开放格式的应用 </description>
    </item>
    <item>
      <title>Pydoc 以及 Docstrings</title>
      <link>http://192.168.2.39:1313/?p=424/</link>
      <pubDate>Fri, 21 Sep 2018 01:00:00 +0800</pubDate>
      <guid>http://192.168.2.39:1313/?p=424/</guid>
      <description>最近写程序的时候十分关注 Docstrings，这个专门用于生成文档注释的东西。这个对于程序员应该可以说是相当友好了。&#xA;Reference https://python-guide.gitbooks.io/python-style-guide/content/style-guide/comment_and_docs.html </description>
    </item>
    <item>
      <title>数据不均衡问题</title>
      <link>http://192.168.2.39:1313/?p=414/</link>
      <pubDate>Mon, 17 Sep 2018 01:00:00 +0800</pubDate>
      <guid>http://192.168.2.39:1313/?p=414/</guid>
      <description></description>
    </item>
    <item>
      <title>algorithm binary_search</title>
      <link>http://192.168.2.39:1313/?p=388/</link>
      <pubDate>Wed, 29 Aug 2018 01:00:00 +0800</pubDate>
      <guid>http://192.168.2.39:1313/?p=388/</guid>
      <description>binary_search 经常被认为是很难快速，一遍写对的算法，我也是这么认为的（笑），但是最近观察了c++ 标准库中的 binary_search ，其实现使用了 std::lower_bound，让我觉得似乎这个事情被我想复杂了。&#xA;另外，C++ 使用指针的时候，应该自豪的使用 unique_ptr，来避免工程上忘记 delete 的问题。&#xA;STL 中可能的实现 这种实现，最后一个元素不作为可用的元素。&#xA;一般的写法 from geek 需要熟悉的 container std::advacne, std::distance.</description>
    </item>
    <item>
      <title>笔记列表</title>
      <link>http://192.168.2.39:1313/2018/03/30/%E7%AC%94%E8%AE%B0%E5%88%97%E8%A1%A8/</link>
      <pubDate>Fri, 30 Mar 2018 01:00:00 +0800</pubDate>
      <guid>http://192.168.2.39:1313/2018/03/30/%E7%AC%94%E8%AE%B0%E5%88%97%E8%A1%A8/</guid>
      <description>sphinx-learn algorithm_note python_note 这些笔记用 Sphinx 进行书写的，Sphinx 着实不是特别好用，学习曲线有些陡峭，后面打算切换到语雀什么的，可能会舒服一些。就是可能不够自由。&#xA;如果喜欢本博客，建议添加 RSS 订阅</description>
    </item>
    <item>
      <title>UML – 学习笔记</title>
      <link>http://192.168.2.39:1313/2015/06/30/uml-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 30 Jun 2015 01:00:00 +0800</pubDate>
      <guid>http://192.168.2.39:1313/2015/06/30/uml-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>用例图 扩展和包含：&#xA;扩展(extend)： extend关系是对基用例的扩展，基用例是一个完整的用例，即使没有子用例的参与，也可以完成一个完整的功能。extend的基用例中将存在一个扩展点，只有当扩展点被激活时，子用例才会被执行。 extend关系在用例图中使用带箭头的虚线表示(在线上标注&amp;laquo;extend&amp;raquo;)，箭头从子用例指向基用例。&#xA;包含(include)： include为包含关系，当两个或多个用例中共用一组相同的动作，这时可以将这组相同的动作抽出来作为一个独立的子用例，供多个基用例所共享。因为子用例被抽出，基用例并非一个完整的用例，所以include关系中的基用例必须和子用例一起使用才够完整，子用例也必然被执行。include关系在用例图中使用带箭头的虚线表示(在线上标注&amp;laquo;include&amp;raquo;)，箭头从基用例指向子用例。&#xA;设计模式 参考的学习资料：&#xA;http://peterwei.iteye.com/blog/958803 图说设计模式 </description>
    </item>
    <item>
      <title>近期算法笔记</title>
      <link>http://192.168.2.39:1313/2015/05/08/%E8%BF%91%E6%9C%9F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 08 May 2015 01:00:00 +0800</pubDate>
      <guid>http://192.168.2.39:1313/2015/05/08/%E8%BF%91%E6%9C%9F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</guid>
      <description>算法书籍&#xA;莫队算法&#xA;最大团&#xA;最短路&#xA;A _搜索算法——图形搜索算法，从给定起点到给定终点计算出路径。其中使用了一种启发式的估算，为每个节点估算通过该节点的最佳路径，并以之为各个地点排定次序。算法以得到的次序访问这些节点。因此，A_搜索算法是最佳优先搜索的范例。&#xA;集束搜索（又名定向搜索，Beam Search）——最佳优先搜索算法的优化。使用启发式函数评估它检查的每个节点的能力。不过，集束搜索只能在每个深度中发现最前面的m个最符合条件的节点，m是固定数字——集束的宽度。&#xA;二分查找（Binary Search）——在线性数组中找特定值的算法，每个步骤去掉一半不符合要求的数据。&#xA;分支界定算法（Branch and Bound）——在多种最优化问题中寻找特定最优化解决方案的算法，特别是针对离散、组合的最优化。&#xA;Buchberger算法——一种数学算法，可将其视为针对单变量最大公约数求解的欧几里得算法和线性系统中高斯消元法的泛化。&#xA;数据压缩——采取特定编码方案，使用更少的字节数（或是其他信息承载单元）对信息编码的过程，又叫来源编码。&#xA;Diffie-Hellman密钥交换算法——一种加密协议，允许双方在事先不了解对方的情况下，在不安全的通信信道中，共同建立共享密钥。该密钥以后可与一个对称密码一起，加密后续通讯。&#xA;Dijkstra算法——针对没有负值权重边的有向图，计算其中的单一起点最短算法。&#xA;离散微分算法（Discrete differentiation）&#xA;动态规划算法（Dynamic Programming）——展示互相覆盖的子问题和最优子架构算法&#xA;欧几里得算法（Euclidean algorithm）——计算两个整数的最大公约数。最古老的算法之一，出现在公元前300前欧几里得的《几何原本》。&#xA;期望-最大算法（Expectation-maximization algorithm，又名EM-Training）——在统计计算中，期望-最大算法在概率模型中寻找可能性最大的参数估算值，其中模型依赖于未发现的潜在变量。EM在两个步骤中交替计算，第一步是计算期望，利用对隐藏变量的现有估计值，计算其最大可能估计值；第二步是最大化，最大化在第一步上求得的最大可能值来计算参数的值。&#xA;快速傅里叶变换（Fast Fourier transform，FFT）——计算离散的傅里叶变换（DFT）及其反转。该算法应用范围很广，从数字信号处理到解决偏微分方程，到快速计算大整数乘积。&#xA;梯度下降（Gradient descent）——一种数学上的最优化算法。&#xA;哈希算法（Hashing）&#xA;堆排序（Heaps）&#xA;Karatsuba乘法——需要完成上千位整数的乘法的系统中使用，比如计算机代数系统和大数程序库，如果使用长乘法，速度太慢。该算法发现于1962年。&#xA;LLL算法（Lenstra-Lenstra-Lovasz lattice reduction）——以格规约（lattice）基数为输入，输出短正交向量基数。LLL算法在以下公共密钥加密方法中有大量使用：背包加密系统（knapsack）、有特定设置的RSA加密等等。&#xA;最大流量算法（Maximum flow）——该算法试图从一个流量网络中找到最大的流。它优势被定义为找到这样一个流的值。最大流问题可以看作更复杂的网络流问题的特定情况。最大流与网络中的界面有关，这就是最大流-最小截定理（Max-flow min-cut theorem）。Ford-Fulkerson 能找到一个流网络中的最大流。&#xA;合并排序（Merge Sort）&#xA;牛顿法（Newton’s method）——求非线性方程（组）零点的一种重要的迭代法。&#xA;Q-learning学习算法——这是一种通过学习动作值函数（action-value function）完成的强化学习算法，函数采取在给定状态的给定动作，并计算出期望的效用价值，在此后遵循固定的策略。Q-leanring的优势是，在不需要环境模型的情况下，可以对比可采纳行动的期望效用。&#xA;两次筛法（Quadratic Sieve）——现代整数因子分解算法，在实践中，是目前已知第二快的此类算法（仅次于数域筛法Number Field Sieve）。对于110位以下的十位整数，它仍是最快的，而且都认为它比数域筛法更简单。&#xA;RANSAC——是“RANdom SAmple Consensus”的缩写。该算法根据一系列观察得到的数据，数据中包含异常值，估算一个数学模型的参数值。其基本假设是：数据包含非异化值，也就是能够通过某些模型参数解释的值，异化值就是那些不符合模型的数据点。&#xA;RSA——公钥加密算法。首个适用于以签名作为加密的算法。RSA在电商行业中仍大规模使用，大家也相信它有足够安全长度的公钥。&#xA;Schönhage-Strassen算法——在数学中，Schönhage-Strassen算法是用来完成大整数的乘法的快速渐近算法。其算法复杂度为：O(N log(N) log(log(N)))，该算法使用了傅里叶变换。&#xA;单纯型算法（Simplex Algorithm）——在数学的优化理论中，单纯型算法是常用的技术，用来找到线性规划问题的数值解。线性规划问题包括在一组实变量上的一系列线性不等式组，以及一个等待最大化（或最小化）的固定线性函数。&#xA;奇异值分解（Singular value decomposition，简称SVD）——在线性代数中，SVD是重要的实数或复数矩阵的分解方法，在信号处理和统计中有多种应用，比如计算矩阵的伪逆矩阵（以求解最小二乘法问题）、解决超定线性系统（overdetermined linear systems）、矩阵逼近、数值天气预报等等。&#xA;求解线性方程组（Solving a system of linear equations）——线性方程组是数学中最古老的问题，它们有很多应用，比如在数字信号处理、线性规划中的估算和预测、数值分析中的非线性问题逼近等等。求解线性方程组，可以使用高斯—约当消去法（Gauss-Jordan elimination），或是柯列斯基分解（ Cholesky decomposition）。</description>
    </item>
  </channel>
</rss>
